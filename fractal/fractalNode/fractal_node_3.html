<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FractalNode Phase 1.2</title>
  <style>
    body { font-family: sans-serif; background: #f0f0f0; margin: 0; overflow: hidden; }
    canvas { background: #fff; display: block; }
    #controls { position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 8px; }
    button { margin-right: 5px; margin-top: 5px; }
    #contextMenu { position:absolute; display:none; background:#eee; border:1px solid #333; padding:5px; z-index:1000; }
    #contextMenu div { padding:5px; cursor:pointer; }
    #contextMenu div:hover { background:#ccc; }
  </style>
</head>
<body>

<div id="controls">
  <button onclick="addBlock('Input')">Add Input</button>
  <button onclick="addBlock('Constant')">Add Constant</button>
  <button onclick="addBlock('Add')">Add Add</button>
  <button onclick="addBlock('Subtract')">Add Subtract</button>
  <button onclick="addBlock('Multiply')">Add Multiply</button>
  <button onclick="addBlock('Divide')">Add Divide</button>
  <button onclick="addBlock('Output')">Add Output</button>
  <br>
  <button onclick="startWiring()">Start Wiring</button>
  <br>
  <button onclick="saveGraph()">Save</button>
  <button onclick="saveGraphAs()">Save As</button>
  <button onclick="loadGraphList()">Load</button>   <!-- ⭐ ADDED BACK HERE -->
  <button onclick="sendGraph()">Send Graph</button>
  <button onclick="runStep()">Run Step</button>
</div>

<div id="contextMenu">
  <div onclick="editBlock()">Edit</div>
  <div onclick="deleteBlock()">Delete</div>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
let lastSavedFilename = "fractalnode_graph.json";
let blocks = [];
let wires = [];
let draggingBlock = null;
let dragOffsetX = 0;
let dragOffsetY = 0;
let rightClickBlock = null;
const contextMenu = document.getElementById('contextMenu');

let wiringMode = false;
let wiringStartBlock = null;
let wiringStartX = 0;
let wiringStartY = 0;

let socket = null;
connectWebSocket();

// --- Block Management ---

function addBlock(type) {
  const block = {
    id: 'node_' + Date.now(),
    type: type,
    x: Math.random() * (canvas.width - 150) + 50,
    y: Math.random() * (canvas.height - 150) + 50,
    config: { value: (type === 'Constant' ? 1 : 0) },
    idName: type === 'Input' ? prompt("Input ID?") || ("in_" + id) : null // For Inputs
  };
  blocks.push(block);
  draw();
}

function finishWire(targetX, targetY) {
  const target = blocks.find(b => targetX >= b.x && targetX <= b.x + blockWidth &&
                                   targetY >= b.y && targetY <= b.y + blockHeight);
  if (target) {
    const inputNum = (targetY - target.y) < (blockHeight/2) ? 1 : 2;
    wires.push({ from: wiringStart, to: target.id, input: inputNum });
  }
  wiringStart = null;
  draw();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw wires
  ctx.strokeStyle = '#000';
  wires.forEach(w => {
    const fromBlock = blocks.find(b => b.id === w.from);
    const toBlock = blocks.find(b => b.id === w.to);
    if (fromBlock && toBlock) {
      ctx.beginPath();
      ctx.moveTo(fromBlock.x + 150, fromBlock.y + 25);
      ctx.lineTo(toBlock.x, toBlock.y + 25);
      ctx.stroke();
    }
  });

  // If wiring in progress
  if (wiringMode && wiringStartBlock) {
    ctx.beginPath();
    ctx.moveTo(wiringStartX, wiringStartY);
    ctx.lineTo(mouseX, mouseY);
    ctx.stroke();
  }

  // Draw blocks
  blocks.forEach(b => {
    ctx.fillStyle = '#ddd';
    ctx.fillRect(b.x, b.y, 150, 50);
    ctx.strokeStyle = '#000';
    ctx.strokeRect(b.x, b.y, 150, 50);

    ctx.fillStyle = '#000';
    ctx.fillText(b.type, b.x + 10, b.y + 20);

    ctx.font = '10px sans-serif';
    ctx.fillText(b.id, b.x + 5, b.y + 45);
    ctx.font = '16px sans-serif'; // Reset

    // Output dot (right side, green)
    ctx.beginPath();
    ctx.fillStyle = 'green';
    ctx.arc(b.x + 150, b.y + 25, 5, 0, 2 * Math.PI);
    ctx.fill();

    // Input dots (left side, blue) if not Constant
    if (b.type !== 'Constant') {
      ctx.beginPath();
      ctx.fillStyle = 'blue';
      ctx.arc(b.x, b.y + 15, 5, 0, 2 * Math.PI);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(b.x, b.y + 35, 5, 0, 2 * Math.PI);
      ctx.fill();
    }
  });
}

// --- Mouse Handling ---

let mouseX = 0, mouseY = 0;

canvas.onmousedown = (e) => {
  hideContextMenu();
  const mx = e.offsetX;
  const my = e.offsetY;
  mouseX = mx;
  mouseY = my;

  const clickedBlock = blocks.find(b => mx >= b.x && mx <= b.x+150 && my >= b.y && my <= b.y+50);
  
  if (wiringMode && clickedBlock) {
    if (!wiringStartBlock) {
      // Starting point (output)
      wiringStartBlock = clickedBlock;
      wiringStartX = clickedBlock.x + 150;
      wiringStartY = clickedBlock.y + 25;
    } else {
      // Ending point (input)
      wires.push({ from: wiringStartBlock.id, to: clickedBlock.id });
      wiringStartBlock = null;
      wiringMode = false;
    }
    draw();
    return;
  }

  draggingBlock = clickedBlock;
  if (e.button === 2 && draggingBlock) {
    e.preventDefault();
    rightClickBlock = draggingBlock;
    showContextMenu(e.pageX, e.pageY);
  } else if (draggingBlock) {
    dragOffsetX = mx - draggingBlock.x;
    dragOffsetY = my - draggingBlock.y;
  }
};

canvas.onmousemove = (e) => {
  mouseX = e.offsetX;
  mouseY = e.offsetY;
  if (draggingBlock) {
    draggingBlock.x = mouseX - dragOffsetX;
    draggingBlock.y = mouseY - dragOffsetY;
    draw();
  } else if (wiringMode) {
    draw();
  }
};

canvas.onmouseup = () => {
  draggingBlock = null;
};

canvas.oncontextmenu = (e) => {
  e.preventDefault();
};

canvas.onclick = (e) => {
  if (wiringMode) {
    const clicked = blocks.find(b => e.offsetX >= b.x && e.offsetX <= b.x + blockWidth &&
                                     e.offsetY >= b.y && e.offsetY <= b.y + blockHeight);
    if (clicked) {
      if (!wiringStart) {
        wiringStart = clicked.id;
      } else {
        const inputNum = (e.offsetY - clicked.y) < (blockHeight/2) ? 1 : 2;
        wires.push({ from: wiringStart, to: clicked.id, input: inputNum });
        wiringStart = null;
      }
    } else {
      wiringStart = null;
    }
    draw();
  } else {
    const clicked = blocks.find(b => e.offsetX >= b.x && e.offsetX <= b.x + blockWidth &&
                                      e.offsetY >= b.y && e.offsetY <= b.y + blockHeight);
    if (clicked) {
      if (clicked.type === 'Input') {
        const newVal = prompt(`Set value for ${clicked.idName}:`, inputVariables[clicked.idName] || 0);
        if (newVal !== null) {
          socket.send(JSON.stringify({ cmd: "set_input_variable", id: clicked.idName, value: parseFloat(newVal) }));
          inputVariables[clicked.idName] = parseFloat(newVal); // Update local immediately
          draw();
        }
      }
    }
  }
};

// --- Context Menu Functions ---

function showContextMenu(x, y) {
  contextMenu.style.left = x + 'px';
  contextMenu.style.top = y + 'px';
  contextMenu.style.display = 'block';
}

function hideContextMenu() {
  contextMenu.style.display = 'none';
}

function editBlock() {
  hideContextMenu();
  if (!rightClickBlock) return;
  if (rightClickBlock.type === 'Constant') {
    const newVal = prompt('Enter new constant value:', rightClickBlock.config.value);
    if (newVal !== null) {
      rightClickBlock.config.value = parseFloat(newVal);
    }
  }
  draw();
}

function deleteBlock() {
  hideContextMenu();
  if (!rightClickBlock) return;
  blocks = blocks.filter(b => b.id !== rightClickBlock.id);
  wires = wires.filter(w => w.from !== rightClickBlock.id && w.to !== rightClickBlock.id);
  draw();
}

// --- Wiring Mode ---

function startWiring() {
  wiringMode = true;
  wiringStartBlock = null;
}

// --- Save / Load / Save As ---
// Save current graph to server
function saveGraph() {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      cmd: "save_graph",
      filename: lastSavedFilename,
      graph: { blocks, wires }
    }));
    alert(`Graph sent to server as: ${lastSavedFilename}`);
  }
}

function xsaveGraph() {
  const graph = { blocks, wires };
  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(graph, null, 2));
  const link = document.createElement('a');
  link.href = dataStr;
  link.download = "fractalnode_graph.json";
  link.click();
}

// SaveAs with prompt
function saveGraphAs() {
  const name = prompt("Enter file name:", lastSavedFilename);
  if (name) {
    lastSavedFilename = name.endsWith('.json') ? name : (name + '.json');
    saveGraph();
  }
}

function xsaveGraphAs() {
  const name = prompt("Enter file name:", lastSavedFilename);
  if (name) {
    lastSavedFilename = name;
    const graph = { blocks, wires };
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(graph, null, 2));
    const link = document.createElement('a');
    link.href = dataStr;
    link.download = lastSavedFilename;
    link.click();
    alert(`Saved: ${lastSavedFilename}`);
  }
}
function xxsaveGraphAs() {
  const name = prompt("Enter file name:", "fractalnode_graph.json");
  if (name) {
    const graph = { blocks, wires };
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(graph, null, 2));
    const link = document.createElement('a');
    link.href = dataStr;
    link.download = name;
    link.click();
  }
}
// Request list of graph files from server
function loadGraphList() {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ cmd: "list_graph_files" }));
  }
}

function loadGraph() {
  const input = document.createElement('input');
  input.type = "file";
  input.onchange = e => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = e2 => {
      const loaded = JSON.parse(e2.target.result);
      blocks = loaded.blocks || [];
      wires = loaded.wires || [];
      draw();
    };
    reader.readAsText(file);
  };
  input.click();
}

// --- WebSocket ---

function connectWebSocket() {
  socket = new WebSocket('ws://localhost:8080');
  socket.onopen = () => console.log('WebSocket Connected');
  socket.onmessage = (event) => {
    const parsed = JSON.parse(event.data);
    if (parsed.cmd === 'update_outputs') {
      parsed.values && updateOutputs(parsed.values);
    }
    else if (parsed.cmd === 'list_graph_files_result') {
        showFileList(parsed.files);
    }

    else if (parsed.cmd === 'load_graph_result') {
        if (parsed.graph) {
        blocks = parsed.graph.blocks || [];
        wires = parsed.graph.wires || [];
        draw();
        alert(`Graph loaded successfully!`);
        } else {
        alert(`Failed to load graph.`);
        }
    }
    
  };
}

// Show list popup
function showFileList(files) {
  const listWindow = window.open("", "Load Graph", "width=400,height=400");
  listWindow.document.write("<h2>Available Graphs</h2>");
  files.forEach(filename => {
    const btn = `<button onclick="window.opener.loadGraphFile('${filename}'); window.close();">${filename}</button><br>`;
    listWindow.document.write(btn);
  });
}

// Actually request to load a file
function loadGraphFile(filename) {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ cmd: "load_graph_file", filename }));
    lastSavedFilename = filename; // Update current filename
  }
}
function sendGraph() {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ cmd: "load_graph", graph: { blocks, wires } }));
  }
}

function runStep() {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ cmd: "run_step" }));
  }
}

function updateOutputs(values) {
  blocks.forEach(b => {
    if (values[b.id] !== undefined) {
      ctx.fillStyle = '#fff';
      ctx.fillRect(b.x, b.y + 55, 150, 20);
      ctx.fillStyle = '#000';
      ctx.fillText("Val: " + values[b.id].toFixed(2), b.x + 10, b.y + 70);
    }
  });
}
</script>

</body>
</html>
