<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FractalNode Phase 1</title>
  <style>
    body { font-family: sans-serif; background: #f0f0f0; margin: 0; overflow: hidden; }
    canvas { background: #fff; display: block; }
    #controls {
      position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 8px;
    }
    button { margin-right: 5px; }
  </style>
</head>
<body>

<div id="controls">
  <button onclick="addBlock('Constant')">Add Constant</button>
  <button onclick="addBlock('Add')">Add Add</button>
  <button onclick="addBlock('Subtract')">Add Subtract</button>
  <button onclick="addBlock('Multiply')">Add Multiply</button>
  <button onclick="addBlock('Divide')">Add Divide</button>
  <button onclick="addBlock('Output')">Add Output</button>
  <button onclick="saveGraph()">Save</button>
  <button onclick="loadGraph()">Load</button>
  <button onclick="sendGraph()">Send Graph</button>
  <button onclick="runStep()">Run Step</button>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let blocks = [];
let wires = [];
let draggingBlock = null;
let dragOffsetX = 0;
let dragOffsetY = 0;

let socket = null;
connectWebSocket();

// --- Block Management ---

function addBlock(type) {
  const block = {
    id: 'node_' + Date.now(),
    type: type,
    x: Math.random() * (canvas.width - 150) + 50,
    y: Math.random() * (canvas.height - 150) + 50,
    config: { value: (type === 'Constant' ? 1 : 0) }
  };
  blocks.push(block);
  draw();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Wires
  ctx.strokeStyle = '#000';
  wires.forEach(w => {
    const fromBlock = blocks.find(b => b.id === w.from);
    const toBlock = blocks.find(b => b.id === w.to);
    if (fromBlock && toBlock) {
      ctx.beginPath();
      ctx.moveTo(fromBlock.x + 75, fromBlock.y + 25);
      ctx.lineTo(toBlock.x + 75, toBlock.y + 25);
      ctx.stroke();
    }
  });

  // Blocks
  blocks.forEach(b => {
    ctx.fillStyle = '#ddd';
    ctx.fillRect(b.x, b.y, 150, 50);
    ctx.strokeStyle = '#000';
    ctx.strokeRect(b.x, b.y, 150, 50);
    ctx.fillStyle = '#000';
    ctx.fillText(b.type, b.x + 10, b.y + 25);
  });
}

// --- Mouse Handling ---

canvas.onmousedown = (e) => {
  const mx = e.offsetX;
  const my = e.offsetY;
  draggingBlock = blocks.find(b => mx >= b.x && mx <= b.x+150 && my >= b.y && my <= b.y+50);
  if (draggingBlock) {
    dragOffsetX = mx - draggingBlock.x;
    dragOffsetY = my - draggingBlock.y;
  }
};

canvas.onmousemove = (e) => {
  if (draggingBlock) {
    draggingBlock.x = e.offsetX - dragOffsetX;
    draggingBlock.y = e.offsetY - dragOffsetY;
    draw();
  }
};

canvas.onmouseup = () => {
  draggingBlock = null;
};

// --- WebSocket ---

function connectWebSocket() {
  socket = new WebSocket('ws://localhost:8080');
  socket.onopen = () => console.log('WebSocket Connected');
  socket.onmessage = (event) => {
    const parsed = JSON.parse(event.data);
    if (parsed.cmd === 'update_outputs') {
      parsed.values && updateOutputs(parsed.values);
    }
  };
}

// --- Save / Load ---

function saveGraph() {
  const graph = { blocks, wires };
  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(graph, null, 2));
  const link = document.createElement('a');
  link.href = dataStr;
  link.download = "fractalnode_graph.json";
  link.click();
}

function loadGraph() {
  const input = document.createElement('input');
  input.type = "file";
  input.onchange = e => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = e2 => {
      const loaded = JSON.parse(e2.target.result);
      blocks = loaded.blocks || [];
      wires = loaded.wires || [];
      draw();
    };
    reader.readAsText(file);
  };
  input.click();
}

function sendGraph() {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ cmd: "load_graph", graph: { blocks, wires } }));
  }
}

function runStep() {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ cmd: "run_step" }));
  }
}

function updateOutputs(values) {
  blocks.forEach(b => {
    if (values[b.id] !== undefined) {
      ctx.fillStyle = '#fff';
      ctx.fillRect(b.x, b.y + 55, 150, 20);
      ctx.fillStyle = '#000';
      ctx.fillText("Val: " + values[b.id].toFixed(2), b.x + 10, b.y + 70);
    }
  });
}
</script>

</body>
</html>
