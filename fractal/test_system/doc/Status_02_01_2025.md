Status:
Its been a struggle to get the sbmu modbus mapped properly.
I think I have it 
I am using the test framework to make sure it all works ( code gets unit tested at the same time)
This is all happening in an offline git repo. I migrate components  and bug fixes as needed to the vendor_esbcm repo.
The original qt api ,  is still valid 
{"action":"set", "seq": 123, "sm_name": "rtos_2", "reg_type": "mb_bits", "offset":1, "data":[1,0,1,0]}
 
But this required several string lookups to get to a particular location and also required knowledge of the offset values.
once I read the data_map into the system
this api will work
 
{"action":"set", "seq": 123, "sm_name": "rtos_2", "reg_type": "mb_bits", "offset":,"summary_total_undervoltage", "data":[1,0,1,0]}
 
   That code ( to digest the data map) will be in place first thing Monday morning. 
 
internally this variable identification is going to be compressed in two ways.
The test system and the aggregation systems will use a compact variable format.
 
// decode_shmdef Function to decode shmdef into rack_num, mem_id, reg_id, and offset
// sbmu:bits[:rack_num]:offset (name or integer)
 
    set sbmu:bits::1 0         set bits:1 to 0 rack is not needed and defaults to 0
    set sbmu:bits:1 0         set bits:1 to 0 rack is not needed and defaults to 0
    set sbmu:bits::summary_total_undervoltage  1
    set sbmu:input:7:State  123    sets rack 7 state to 123
 
note that the rack_number can be optional since some sbmu modbus mappings are rack based while others are not.
 
 
The Gold modbus sbmu mapping is a disaster
 
 
the offset up to a certain value is for sbmu summary data 
then past a certain address it reflects rack data the reg address is used to select that rack number
for example 100 is rack 0
3100 is rack 1
6100 is rack 2
 
the rack start addresses  and data sizes are different for different data types.
 
For setting holding registers, a different technique is use where register 500 is used as the rack number and then writes to 100 + are directed to the selected rack.
 
So this is what I am doing .
The "offset only" addressing will work , if you specify rack_num as 0 but read from offset 6100 the read will be related to data from rack_number 2 by virtue of the offset.
if you specify rack_num 2 and try to read data from offset 100 you will get the rack 2 value.
  
Infernally this is being optimized even more.
the api can specify the extended original format 
 
{"action":"set", "seq": 123, "sm_name": "rtos_2", "reg_type": "mb_bits", "offset":1, "data":[1,0,1,0]}
 
or the compact format 
 
(sbmu:bits::1 0  )
 
in either case this is turned into an uint32_t id
 
get sbmu:bits:1
this is turned into an id 
id  <0x11000001>
url  [ws://192.168.86.209:9003]

and is used in the new query option
query  [{"action":"get", "sec":202, "sm_name":"0x11000001", "num":1, "data":[0]}]
response  [{ "seq": 202, "data": [0] }
]
 
there is a good reason for doing this.
When the system is reading data from the racks 5 times (or more) per second.
While we use the Gold layout we will have to shuttle data around  to satisfy their data mapping.
I want to specify the transfer operations  and also the alarm / fault detection and sequencing  operations using string type descriptions that are executed using the var_id.
So all the string based variable descriptions are turned into uint32 ids in the run time code.
 
I should have the mapping in the production code by Monday. I hope to have the transfer code and aggregation code  in place ( i mean transferred to the new system) mid week.
The prototype transfer code / aggregation code is already running in the release with compiled in config definitions.
The config definitions will be in an external json file mid week.
this is also leading up to the requirement that the system config ( now all Can based) can become config based.
   
This is taking a bit of work to get in place but the resulting product will be worth it.
With a web based config viewer / generator we should be in good shape.
 
I have prototypes for the web stuff in my back pocket. If we get the right guy on the job it should be a breeze ( Jimmy please).
 
 