<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fractal SBMS Config</title>
  <style>
    #topButtons {
      margin-bottom: 20px;
    }

    #topButtons button {
      padding: 10px 20px;
      font-size: 1em;
      border: 2px solid black;
      border-radius: 5px;
      background-color: white;
      color: black;
      font-weight: normal;
      margin-right: 10px;
      cursor: pointer;
    }
    body { font-family: sans-serif; background: #f0f0f0; padding: 20px; }
    .tabs { display: flex; overflow-x: auto; margin-bottom: 20px; }
    .tab { background: #ddd; padding: 10px 20px; margin-right: 5px; border-radius: 5px; cursor: pointer; white-space: nowrap; }
    .tab.active { background: #666; color: white; }
    .box { background: white; border: 2px solid #333; padding: 10px; margin: 10px 0; border-radius: 8px; }
    .field-row { display: flex; align-items: center; margin-bottom: 8px; }
    .field-label { width: 150px; font-weight: bold; }
    .field-default { margin-left: 10px; font-style: italic; color: #666; width: 120px; }
    .field-input { flex: 1; margin: 0 5px; }
    .field-buttons button { margin-left: 5px; font-size: 0.9em; }
    #reloadButton { margin-bottom: 20px; padding: 10px 20px; font-size: 1em; }
    #tableSelector { margin-bottom: 10px; padding: 5px; }
    table { width: 100%; background: white; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #ccc; padding: 5px; text-align: left; }
  </style>
</head>
<body>
  <h1>Fractal SBMS Config</h1>
  <div style="display: flex; justify-content: space-between; align-items: center;">
  <div id="tabs" class="tabs"></div>
  <div id="currentFrameLabel" style="font-size: 1.2em; font-weight: bold; margin-bottom: 10px;"></div>

  <div id="wsStatus" style="font-weight: bold; font-size: 1em; margin-left: 10px;">🔴 Disconnected</div>
</div>

  <div class="tabs" id="tabs"></div>
  <div id="topButtons">
    <button id="reloadButton" onclick="reloadData()">Reload</button>
    <button id="editButton" onclick="toggleEditMode()">Edit Mode: OFF</button>
    <button id="loadButton" onclick="loadFrame()">Load</button>
    <button id="saveButton" onclick="saveFrame()">Save</button>
    <button id="saveAsButton" onclick="saveAsFrame()">Save As</button>
    <button id="pollingButton" onclick="togglePolling()" disabled>Start Polling</button>
    <span id="currentFileLabel" style="margin-left: 20px; font-style: italic; color: #555;"></span>


  </div>
  <div id="container">Connecting...</div>

<script>
let highlightUpdates = false;

let pollingActive = false;
let pollingInterval = null;
let currentFileName = "default_frame.json";
//let dataSets = {};
let popupInsertMode = null; // "before" or "after"
let frameData = null; // Global
let contextField = null;    // Stores which field was right-clicked
let contextBoxIndex = null; // Box containing the field
let contextFieldIndex = null; // Index of the field inside the box
let editMode = false;
let wsUrl = "ws://localhost:8080";
let wsIp = "localhost";
let wsPort = "8080";
let socket = null;
let connected = false;
let liveData = null;
let currentFrame = "config";
let currentTable = "volt";

const fakeData = { 
  "cmd": "load_frame",
  "data": {
    "frames": { 
      "config": {
        "boxes": [
          {
            "title": "Config",
            "fields": [
              { "name":"Setting 1", "value":"Value1", "input":true, "default":"Value1" },
              { "name": "Max Charge Current (A)", "value": "100", "input": true, "default": "100" },
              { "name": "Max Discharge Current (A)", "value": "120", "input": true, "default": "120" },
              { "name": "Nominal Voltage (V)", "value": "3.700", "input": true, "default": "3.700" },
              { "name": "Nominal Capacity (Ah)", "value": "200", "input": true, "default": "200" },
              { "name": "Balance Threshold (mV)", "value": "10", "input": true, "default": "10" }
            ]
          }
        ]
      },
      "param": {
        "boxes": [
          {
            "title": "Parameters",
            "fields": [
              { "name": "Param A", "value": "10", "input": true, "default": "10" }
            ]
          }
        ]
      }
    }
  }
};

// Add the racks inside data.frames
for (let i = 0; i <= 12; i++) {
  fakeData.data.frames["rack" + i] = {
    "boxes": [
      {
        "title": "Rack " + i,
        "fields": [
          { "name": "Rack Setting", "value": "Enabled", "input": true, "default": "Enabled" }
        ]
      }
    ],
    "tables": {
      "volt": Array(64).fill(+(3.7 + 0.01 * i).toFixed(3)),
      "soc": Array(64).fill(95 + (i % 5)),
      "soh": Array(64).fill(90 + (i % 5)),
      "temp": Array(64).fill(25 + i)
    }
  };
}

function togglePolling() {
  if (!connected) return; // Shouldn't happen, but safe

  pollingActive = !pollingActive;

  const btn = document.getElementById('pollingButton');
  btn.textContent = pollingActive ? "Stop Polling" : "Start Polling";

  if (pollingActive) {
    startPollingData();
  } else {
    stopPollingData();
  }
}

function startPollingData() {
  if (pollingInterval) clearInterval(pollingInterval);
  
  pollingInterval = setInterval(() => {
    if (socket && connected && currentFrame && frameData && frameData.frames && frameData.frames[currentFrame]) {
      const activeFrame = frameData.frames[currentFrame];

      // Always poll the box data
      const boxSetName = currentFrame + "_box_data_set";
      socket.send(JSON.stringify({ cmd: "get_data_set_values", name: boxSetName }));

      // Poll the table if any table is active
      if (activeFrame.tables && currentTable) {
        const tableSetName = currentFrame + "_table_" + currentTable + "_data_set";
        socket.send(JSON.stringify({ cmd: "get_data_set_values", name: tableSetName }));
      }
    }
  }, 1000); // Poll every second (adjust if needed)
}

function stopPollingData() {
  if (pollingInterval) {
    clearInterval(pollingInterval);
    pollingInterval = null;
  }
}

function updateCurrentFileLabel() {
  const label = document.getElementById('currentFileLabel');
  if (label) {
    label.textContent = `📄 ${currentFileName}`;
  }
}

function popup(message, isSuccess = true) {
  const div = document.createElement('div');
  div.style.position = 'fixed';
  div.style.top = '20px';
  div.style.right = '20px';
  div.style.padding = '10px 20px';
  div.style.backgroundColor = isSuccess ? 'green' : 'red';
  div.style.color = 'white';
  div.style.fontWeight = 'bold';
  div.style.borderRadius = '8px';
  div.style.zIndex = 1000;
  div.textContent = message;
  document.body.appendChild(div);

  setTimeout(() => {
    div.remove();
  }, 3000); // 3 seconds then disappear
}

function validateFrameData(data) {
  if (!data || typeof data !== 'object') {
    console.error("Validation Failed: frameData is not an object!");
    return null;
  }

  if (!data.frames || typeof data.frames !== 'object') {
    console.error("Validation Failed: Missing 'frames' object inside frameData.");
    return null;
  }

  const frameNames = Object.keys(data.frames);
  if (frameNames.length === 0) {
    console.error("Validation Failed: 'frames' object is empty.");
    return null;
  }

  frameNames.forEach(frameName => {
    const frame = data.frames[frameName];
    if (!frame.boxes || !Array.isArray(frame.boxes)) {
      console.warn(`Frame '${frameName}' missing 'boxes'. Auto-creating empty array.`);
      frame.boxes = [];
    }

    frame.boxes.forEach((box, boxIndex) => {
      if (!box.fields || !Array.isArray(box.fields)) {
        console.warn(`Box ${boxIndex} in frame '${frameName}' missing 'fields'. Auto-creating empty array.`);
        box.fields = [];
      }

      box.fields = box.fields.filter((field, fieldIndex) => {
        if (!field.name || (field.value === undefined && field.default === undefined)) {
          console.warn(`Invalid field removed in frame '${frameName}', box ${boxIndex}, field ${fieldIndex}.`);
          return false;
        }
        return true;
      });
    });
  });

  console.log("Validation Complete: frameData structure is now safe.");
  return data;
}

function updateCurrentFrameLabel() {
  // const label = document.getElementById('currentFrameLabel');
  // if (label && currentFrame) {
  //   label.textContent = `Current Frame: ${currentFrame}`;
  //  }
}

function updateConnectionStatus(isConnected) {
  const statusDiv = document.getElementById('wsStatus');
  if (!statusDiv) return;

  if (isConnected) {
    statusDiv.innerHTML = "🟢 Connected";
    statusDiv.style.color = "green";
  } else {
    statusDiv.innerHTML = "🔴 Disconnected";
    statusDiv.style.color = "red";
  }
  // Now control button backgrounds
  const buttons = ["loadButton", "saveButton", "saveAsButton"];
  buttons.forEach(id => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.style.backgroundColor = isConnected ? "white" : "lightgrey";
      btn.disabled = !isConnected;
      btn.style.cursor = isConnected ? "pointer" : "not-allowed";
    }
  });
}

function loadFrame() {
  if (socket && connected) {
    socket.send(JSON.stringify({ cmd: "list_frames" , requestor: "load" }));
  } else {
    console.warn("WebSocket not connected. Cannot list frames.");
  }
}


function saveFrame() {
  if (socket && connected && frameData) {
    socket.send(JSON.stringify({ cmd: "save_frame", requestor: "saveas" }));
    console.log("Save frame request sent.");
  }
}

function saveAsFrame() {
  if (socket && connected && frameData) {
    socket.send(JSON.stringify({ cmd: "list_frames",requestor: "saveas" }));
    console.log("Requested file list for SaveAs selection.");
  }
}



function toggleEditMode() {
  editMode = !editMode;
  const editButton = document.getElementById('editButton');
  if (editMode) {
    editButton.textContent = "Edit Mode: ON";
    editButton.style.backgroundColor = "#ffd700"; // Strong Gold-Yellow
    editButton.style.color = "black"; // Black text
    editButton.style.fontWeight = "bold"; // Bold font
    editButton.style.border = "2px solid black"; // Stronger button border
  } else {
    editButton.textContent = "Edit Mode: OFF";
    editButton.style.backgroundColor = "";
    editButton.style.color = "";
    editButton.style.fontWeight = "";
    editButton.style.border = "";
  }
}

function buildTabs(data) {
  const tabs = document.getElementById('tabs');
  tabs.innerHTML = '';
  const frames = ["connect", ...Object.keys(data.frames)];
  frames.forEach(frame => {
    const tab = document.createElement('div');
    tab.className = 'tab';
    tab.textContent = frame;
    if (frame === currentFrame) tab.classList.add('active');
    tab.onclick = () => {
      currentFrame = frame;
      buildTabs(data);
      updateCurrentFrameLabel(); // ✅ Add this
      if (frame === "connect") showConnect();
      else createBoxes(data.frames[frame]);
    };
    tabs.appendChild(tab);
  });
}

function showConnect() {
  const container = document.getElementById('container');
  container.innerHTML = `
    <div class="box">
      <h2>Connect to WebSocket</h2>
      <label>IP:</label> <input id="wsIp" value="${wsIp}"><br><br>
      <label>Port:</label> <input id="wsPort" value="${wsPort}"><br><br>
      <button onclick="applyConnect()">Connect</button>
    </div>
  `;
}

function applyConnect() {
  wsIp = document.getElementById('wsIp').value;
  wsPort = document.getElementById('wsPort').value;
  wsUrl = "ws://" + wsIp + ":" + wsPort;
  connectWebSocket();
}

function showContextMenu(x, y) {
  const menu = document.getElementById('contextMenu');
  menu.style.left = x + "px";
  menu.style.top = y + "px";
  menu.style.display = "block";
}

function hideContextMenu() {
  const menu = document.getElementById('contextMenu');
  menu.style.display = "none";
}


// Hide menu if click elsewhere
document.addEventListener("click", function() {
  hideContextMenu();
});

function deleteField() {
  console.log("Delete clicked frameData", frameData);
  console.log("Delete clicked", contextBoxIndex, contextFieldIndex);
  if (contextBoxIndex !== null && contextFieldIndex !== null) {
    frameData.frames[currentFrame].boxes[contextBoxIndex].fields.splice(contextFieldIndex, 1);
    hideContextMenu();
    createBoxes(frameData.frames[currentFrame]);
  }
}

function addFieldBefore() {
  if (contextBoxIndex !== null && contextFieldIndex !== null) {
    popupInsertMode = "before";
    showFieldPopup();
    hideContextMenu();
  }
}

function addFieldAfter() {
  if (contextBoxIndex !== null && contextFieldIndex !== null) {
    popupInsertMode = "after";
    showFieldPopup();
    hideContextMenu();
  }
}

function createBoxes(frameData) {
  const container = document.getElementById('container');
  container.innerHTML = '';

  //frameData.frames[currentFrame].boxes.forEach((box, boxIndex) => {
  frameData.boxes.forEach((box, boxIndex) => {
      const div = document.createElement('div');
    div.className = 'box';
    const title = document.createElement('h2');
    title.textContent = box.title;
    div.appendChild(title);

    box.fields.forEach((field, fieldIndex) => {
      const row = document.createElement('div');
      row.className = 'field-row';

      // Add Right-Click (Context Menu) Only If Edit Mode Active
      row.oncontextmenu = (e) => {
        if (editMode) {
          e.preventDefault(); // prevent default browser menu
          contextField = field;
          contextBoxIndex = boxIndex;
          contextFieldIndex = fieldIndex;
          showContextMenu(e.pageX, e.pageY);
        }
      };
      const label = document.createElement('div');
      label.className = 'field-label';
      label.textContent = field.name + ":";
      row.appendChild(label);

      if (field.input) {
        const defVal = document.createElement('div');
        defVal.className = 'field-default';
        defVal.textContent = "Default: " + field.default;
        row.appendChild(defVal);

        const input = document.createElement('input');
        input.type = "text";
        input.value = field.value;
        input.className = 'field-input';
        if(field.id) {
          input.setAttribute('data-id', field.id);
        }

        if (field.dirty) {
          input.style.backgroundColor = "#ffffcc"; // Restore highlight when rebuilding
        };

        input.oninput = () => {
          frameData.boxes[boxIndex].fields[fieldIndex].value = input.value;
          frameData.boxes[boxIndex].fields[fieldIndex].dirty = (input.value !== field.default);
          if (frameData.boxes[boxIndex].fields[fieldIndex].dirty) {
            input.style.backgroundColor = "#ffffcc"; // Light yellow if dirty
          } else {
            input.style.backgroundColor = ""; // Clear highlight if matches default
          }
        };
        row.appendChild(input);

        const buttonSet = document.createElement('div');
        buttonSet.className = 'field-buttons';
        const setBtn = document.createElement('button');
        setBtn.textContent = "Set";
        setBtn.onclick = () => {
          if (socket && connected) socket.send(JSON.stringify({ field: field.name, value: input.value }));
          frameData.boxes[boxIndex].fields[fieldIndex].value = input.value;
        };
        buttonSet.appendChild(setBtn);
        const clearBtn = document.createElement('button');
        clearBtn.textContent = "Clear";
        clearBtn.onclick = () => { input.value = ""; frameData.boxes[boxIndex].fields[fieldIndex].value = ""; };
        buttonSet.appendChild(clearBtn);
        const defaultBtn = document.createElement('button');
        defaultBtn.textContent = "Default";
        defaultBtn.onclick = () => { input.value = field.default; frameData.boxes[boxIndex].fields[fieldIndex].value = field.default; };
        buttonSet.appendChild(defaultBtn);
        row.appendChild(buttonSet);
      } else {
        const staticValue = document.createElement('div');
        staticValue.className = 'field-default';
        staticValue.textContent = field.value;
        row.appendChild(staticValue);
      }

      div.appendChild(row);
    });

    container.appendChild(div);
  });

  if (frameData.tables) {
    const tableSelect = document.createElement('select');
    tableSelect.id = 'tableSelector';
    ["volt", "soc", "soh", "temp"].forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = t.toUpperCase();
      if (t === currentTable) opt.selected = true;
      tableSelect.appendChild(opt);
    });
    tableSelect.onchange = () => {
      currentTable = tableSelect.value;
      renderTable(frameData);
    };
    container.appendChild(tableSelect);
    renderTable(frameData);
  }
}

function buildDataSets(frameData) {
  let dataSets = {};
  Object.keys(frameData.frames).forEach(frameName => {
    const frame = frameData.frames[frameName];
    if (!frame) return;

    // Boxes (fields)
    if (frame.boxes) {
      let boxSetName = frameName + "_box_data_set";
      dataSets[boxSetName] = [];
      frame.boxes.forEach(box => {
        box.fields.forEach(field => {
          if (field.id) {
            dataSets[boxSetName].push(field.id);
          }
        });
      });
    }

    // Tables (volt, soc, soh, temp, etc.)
    if (frame.tables) {
      Object.keys(frame.tables).forEach(tableName => {
        let tableSetName = frameName + "_table_" + tableName + "_data_set";
        dataSets[tableSetName] = [];
        frame.tables[tableName].forEach(item => {
          if (item.id) {
            dataSets[tableSetName].push(item.id);
          }
        });
      });
    }
  });
  
  console.log(`dataSets:`);
  console.log(dataSets);

  return dataSets;
}


function register_dataSets(dataSets) {

  // NEW: Immediately send to WebSocket if connected
  if (socket && connected) {
    socket.send(JSON.stringify({
      cmd: "register_data_sets",
      data_sets: dataSets
    }));
    console.log(`Sent register_data_sets with ${Object.keys(dataSets).length} sets.`);
  } else {
    console.warn("Socket not connected, cannot send data_sets yet.");
  }

}



function sanitize(str) {
  return str.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
}

// function initializeFrameIDs(frameData) {
//   console.log(`running initialize ids`);
//   console.log(frameData);
//   if (!frameData || !frameData.boxes) {
//     console.log(`no boxes in frameData`);
//     return;
//   }
//   frameData.boxes.forEach(box => {
//     box.fields.forEach(field => {
//       if (!field.id) {
//         field.id = sanitize(box.title) + "_" + sanitize(field.name);
//         console.log(`Auto-assigned ID [${field.id}]`);
//       }
//     });
//   });
// }
function initializeAllFrames(frames) {
  if (!frames) {
    console.warn(`No frames to initialize.`);
    return;
  }

  Object.keys(frames).forEach(frameName => {
    const frameData = frames[frameName];

    if (isFrame(frameData)) {
      // Real frame object (has boxes or tables)
      initializeFrameIDs(frameName, frameData);
    } else if (typeof frameData === 'object') {
      // It's a nested container, walk deeper
      console.warn(`Nested structure detected in [${frameName}], descending...`);
      initializeAllFrames(frameData);
    }
  });
}

// Helper to detect if it's a real frame
function isFrame(obj) {
  if (!obj) return false;
  return obj.boxes || obj.tables;
}


function initializeFrameIDs(frameName, frameData) {
  console.log(`Running initialize IDs for frame [${frameName}]`);

  if (!frameData) {
    console.warn(`FrameData missing for [${frameName}]`);
    return;
  }

  // Initialize fields in boxes
  if (frameData.boxes) {
    frameData.boxes.forEach(box => {
      box.fields.forEach(field => {
        if (!field.id) {
          field.id = sanitize(frameName) + "_" + sanitize(box.title) + "_" + sanitize(field.name);
          //console.log(`Auto-assigned Field ID [${field.id}]`);
        }
      });
    });
  }

  // Initialize entries in tables
  if (frameData.tables) {
    Object.keys(frameData.tables).forEach(tableName => {
      frameData.tables[tableName] = frameData.tables[tableName].map((entry, idx) => {
        if (typeof entry === 'object' && entry.id !== undefined) {
          return entry; // Already has id
        }
        return {
          id: sanitize(frameName) + "_" + sanitize(tableName) + "_" + idx,
          value: entry
        };
      });
      //console.log(`Initialized Table [${frameName}.${tableName}]`);
    });
  }
}

function sanitize(str) {
  return str.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
}

function editField() {
  if (contextField && contextBoxIndex !== null && contextFieldIndex !== null) {
    showFieldPopup(true); // ✅ Trigger popup with edit mode
    hideContextMenu();
  }
}

function showFieldPopup(isEdit = false) {
  document.getElementById('popupFieldName').value = isEdit ? contextField.name : "";
  document.getElementById('popupFieldDefault').value = isEdit ? contextField.default : "";
  document.getElementById('popupFieldInput').checked = isEdit ? contextField.input : true;
  document.getElementById('fieldPopup').style.display = "block";
  popupInsertMode = isEdit ? "edit" : popupInsertMode;
}

function xshowFieldPopup() {
  document.getElementById('popupFieldName').value = "";
  document.getElementById('popupFieldDefault').value = "";
  document.getElementById('popupFieldInput').checked = true;
  document.getElementById('fieldPopup').style.display = "block";
}

function cancelNewField() {
  document.getElementById('fieldPopup').style.display = "none";
}

function confirmNewField() {
  const name = document.getElementById('popupFieldName').value || "New Field";
  const def = document.getElementById('popupFieldDefault').value || "";
  const isInput = document.getElementById('popupFieldInput').checked;

  const newField = {
    name: name,
    value: def,
    input: isInput,
    default: def
  };

  if (contextBoxIndex !== null && contextFieldIndex !== null) {
    if (popupInsertMode === "before") {
      frameData.frames[currentFrame].boxes[contextBoxIndex].fields.splice(contextFieldIndex, 0, newField);
    } else if (popupInsertMode === "after") {
      frameData.frames[currentFrame].boxes[contextBoxIndex].fields.splice(contextFieldIndex + 1, 0, newField);
    } else if (popupInsertMode === "edit") {
      // ✅ Overwrite current field
      Object.assign(frameData.frames[currentFrame].boxes[contextBoxIndex].fields[contextFieldIndex], newField);
    }
    createBoxes(frameData.frames[currentFrame]);
  }

  document.getElementById('fieldPopup').style.display = "none";
}


function renderTable(frameData) {
  let table = document.getElementById('batteryTable');
  if (table) table.remove();

  table = document.createElement('table');
  table.id = 'batteryTable';

  const header = table.insertRow();
  for (let i = 0; i < 8; i++) {
    const cell = header.insertCell();
    cell.textContent = `Cell ${i}`;
  }

  const data = frameData.tables[currentTable] || [];

  for (let rowStart = 0; rowStart < data.length; rowStart += 8) {
    const row = table.insertRow();
    for (let i = 0; i < 8; i++) {
      const cell = row.insertCell();
      if (rowStart + i < data.length) {
        let valEntry = data[rowStart + i];

        let val;
        let id;
        if (typeof valEntry === 'object' && valEntry.hasOwnProperty('value')) {
          val = valEntry.value;
          id = valEntry.id;
        } else {
          val = valEntry;
          id = null;
        }

        if (typeof val === 'number') {
          cell.textContent = val.toFixed(3);
          applyColorCoding(cell, val, currentTable);
        } else {
          cell.textContent = val || "";
        }

        if (id) {
          cell.setAttribute('data-id', id);
        }

      } else {
        cell.textContent = "";
      }
    }
  }

  document.getElementById('container').appendChild(table);
}

function xrenderTable(frameData) {
  let table = document.getElementById('batteryTable');
  if (table) table.remove();

  table = document.createElement('table');
  table.id = 'batteryTable';

  const header = table.insertRow();
  for (let i = 0; i < 8; i++) {
    const cell = header.insertCell();
    cell.textContent = `Cell ${i}`;
  }

  const data = frameData.tables[currentTable] || [];
  for (let rowStart = 0; rowStart < data.length; rowStart += 8) {
    const row = table.insertRow();
    for (let i = 0; i < 8; i++) {
      const cell = row.insertCell();
      if (rowStart + i < data.length) {
        const val = data[rowStart + i];
        cell.textContent = val.toFixed(3);
        applyColorCoding(cell, val, currentTable);
      } else {
        cell.textContent = "";
      }
    }
  }

  document.getElementById('container').appendChild(table);
}

function applyColorCoding(cell, value, tableType) {
  if (tableType === "volt") {
    if (value < 3.0 || value > 3.8) {
      cell.style.background = "#ff9999"; // Light Red
    }
  } else if (tableType === "soc") {
    if (value < 20 || value > 100) {
      cell.style.background = "#ffcc66"; // Orange
    }
  } else if (tableType === "soh") {
    if (value < 80) {
      cell.style.background = "#ffff99"; // Yellow
    }
  } else if (tableType === "temp") {
    if (value < 0 || value > 60) {
      cell.style.background = "#ff9999"; // Light Red
    }
  }
}

function reloadData() {
  if (liveData && liveData.data) {
    const validated = validateFrameData(liveData.data);
    if (!validated) {
      console.error("Live data invalid. Falling back to fakeData.");
      frameData = fakeData.data;
      currentFrame = "config";
      updateCurrentFrameLabel(); // ✅ Add this
    } else {
      frameData = validated;
    }
  } else {
    const validated = validateFrameData(fakeData.data);
    if (!validated) {
      console.error("Fallback fakeData invalid. Critical error!");
      document.getElementById('container').innerHTML = "<h2>Error: No valid data to display!</h2>";
      return;
    }
    frameData = validated;
    currentFrame = "config";
  }

  initializeAllFrames(frameData);
  frameData.dataSets = buildDataSets(frameData);
  register_dataSets(frameData.dataSets);

  buildTabs(frameData);

  if (typeof currentFrame !== 'string' || !(currentFrame in frameData.frames)) {
    const availableFrames = Object.keys(frameData.frames);
    currentFrame = availableFrames.length > 0 ? availableFrames[0] : null;
    updateCurrentFrameLabel(); // ✅ Add this
  }

  if (currentFrame && frameData.frames[currentFrame]) {
    createBoxes(frameData.frames[currentFrame]);
  } else {
    document.getElementById('container').innerHTML = "<h2>Error: No valid frame found!</h2>";
  }
}

function popupFileList(files, mode = "load") {
  const popup = document.createElement('div');
  popup.style.position = 'fixed';
  popup.style.top = '50px';
  popup.style.right = '50px';
  popup.style.backgroundColor = 'white';
  popup.style.border = '2px solid black';
  popup.style.padding = '20px';
  popup.style.zIndex = 1000;
  popup.style.borderRadius = '8px';

  const title = document.createElement('div');
  //title.textContent = "Select a Frame to Load";
  title.textContent = (mode === "saveas") ? "Select a Frame to Save As" : "Select a Frame to Load";
  title.style.fontWeight = 'bold';
  title.style.marginBottom = '10px';
  popup.appendChild(title);

  files.forEach(file => {
    const fileButton = document.createElement('button');
    fileButton.textContent = file;
    fileButton.style.display = 'block';
    fileButton.style.margin = '5px 0';
    fileButton.onclick = () => {

      if (mode === "load") {
        currentFileName = file;            // ✅ Save selected name
        updateCurrentFileLabel();  
        socket.send(JSON.stringify({ cmd: "load_frame", file: file }));
        popup.remove();
      } else if (mode === "saveas") {
        confirmPopup(`Overwrite '${file}'?`, () => {
          currentFileName = file;            // ✅ Save selected name
          updateCurrentFileLabel();  
          sendSaveAs(file);
          popup.remove();
        });
      }
    };
    popup.appendChild(fileButton);
  });
  if (mode === "saveas") {
    const newButton = document.createElement('button');
    newButton.textContent = "🆕 New...";
    newButton.style.marginTop = '10px';
    newButton.style.fontWeight = 'bold';
    newButton.onclick = () => {
      popup.remove();
        showNewFilePrompt();  // 👇 We'll define this next
      };
      popup.appendChild(newButton);
  };

  function showNewFilePrompt() {
  const div = document.createElement('div');
  div.style.position = 'fixed';
  div.style.top = '50px';
  div.style.right = '50px';
  div.style.padding = '20px';
  div.style.backgroundColor = 'white';
  div.style.border = '2px solid black';
  div.style.borderRadius = '8px';
  div.style.zIndex = 1000;
  div.style.textAlign = 'center';

  const title = document.createElement('div');
  title.textContent = "Enter New Filename:";
  title.style.marginBottom = '10px';
  div.appendChild(title);

  const input = document.createElement('input');
  input.type = 'text';
  input.placeholder = 'example_frame.json';
  input.style.width = '90%';
  div.appendChild(input);

  const saveBtn = document.createElement('button');
  saveBtn.textContent = "Save";
  saveBtn.style.margin = '10px 5px';
  saveBtn.onclick = () => {
    const name = input.value.trim();
    if (name) {
      sendSaveAs(name);
      div.remove();
    } else {
      alert("Please enter a valid filename.");
    }
  };
  div.appendChild(saveBtn);

  const cancelBtn = document.createElement('button');
  cancelBtn.textContent = "Cancel";
  cancelBtn.onclick = () => div.remove();
  div.appendChild(cancelBtn);

  document.body.appendChild(div);
}

  const cancelButton = document.createElement('button');
  cancelButton.textContent = "Cancel";
  cancelButton.style.marginTop = '10px';
  cancelButton.onclick = () => popup.remove();
  popup.appendChild(cancelButton);

  document.body.appendChild(popup);
}

function confirmPopup(message, yesCallback) {
  const div = document.createElement('div');
  div.style.position = 'fixed';
  div.style.top = '50px';
  div.style.right = '50px';
  div.style.padding = '20px';
  div.style.backgroundColor = 'white';
  div.style.border = '2px solid black';
  div.style.borderRadius = '8px';
  div.style.zIndex = 1000;
  div.style.textAlign = 'center';

  const msg = document.createElement('div');
  msg.style.marginBottom = '10px';
  msg.textContent = message;
  div.appendChild(msg);

  const yesBtn = document.createElement('button');
  yesBtn.textContent = 'Yes';
  yesBtn.style.margin = '5px';
  yesBtn.onclick = () => {
    yesCallback();
    div.remove();
  };
  div.appendChild(yesBtn);

  const noBtn = document.createElement('button');
  noBtn.textContent = 'No';
  noBtn.style.margin = '5px';
  noBtn.onclick = () => div.remove();
  div.appendChild(noBtn);

  document.body.appendChild(div);
}

function sendSaveAs(name) {
  if (socket && connected && frameData) {
    socket.send(JSON.stringify({ cmd: "saveas_frame", name: name, data: frameData }));
    console.log("SaveAs frame sent:", name);
  }
}

function xstartPollingData() {
  setInterval(() => {
    if (socket && connected && currentFrame && frameData && frameData.frames && frameData.frames[currentFrame]) {
      const activeFrame = frameData.frames[currentFrame];

      // Always ask for the box data
      const boxSetName = currentFrame + "_box_data_set";
      socket.send(JSON.stringify({ cmd: "get_data_set_values", name: boxSetName }));

      // If a table is visible, ask for table data too
      if (activeFrame.tables && currentTable) {
        const tableSetName = currentFrame + "_table_" + currentTable + "_data_set";
        socket.send(JSON.stringify({ cmd: "get_data_set_values", name: tableSetName }));
      }
    }
  }, 1000); // 1 second polling rate (adjust as needed)
}

function applyIncomingValues(values) {
  console.log(values);
  for (const [id, value] of Object.entries(values)) {
    const input = document.querySelector(`input[data-id='${id}']`);
    if (input) {
      input.value = value;
      if (highlightUpdates) {
        input.style.backgroundColor = "#d0ffd0"; // light green flash
        setTimeout(() => input.style.backgroundColor = "", 500);
      }
    }

    const tableCell = document.querySelector(`td[data-id='${id}']`);
    if (tableCell) {
      const numericVal = parseFloat(value);
      tableCell.textContent = numericVal.toFixed(3);
      //tableCell.textContent = parseFloat(value).toFixed(3);
      
      if (highlightUpdates) {
        tableCell.style.backgroundColor = "#d0ffd0"; // flash green
        setTimeout(() => {
          tableCell.style.backgroundColor = ""; // clear highlight
          applyColorCoding(tableCell, numericVal, currentTable);
        }, 500);
      } else {
        applyColorCoding(tableCell, numericVal, currentTable);
      }
    }
  }
}

function connectWebSocket() {
  socket = new WebSocket(wsUrl);
  connected = false;
  //frameData = fakeData;

  socket.onopen = () => { 
    connected = true; 
    console.log("Connected"); 
    updateConnectionStatus(true);
    document.getElementById('pollingButton').disabled = false;
    popup("Connected to WebSocket ✅", true);
  };

  socket.onmessage = (event) => {
    try { 
      const parsed = JSON.parse(event.data);
      if (parsed.cmd === "load_frame") {
        console.log("Received frame from server");
        console.log("parsed.data:", parsed.data); // <--- ADD THIS
        liveData = parsed.data;
        frameData = parsed.data; 

        initializeAllFrames(frameData);
        frameData.dataSets = buildDataSets(frameData);
        register_dataSets(frameData.dataSets);

        buildTabs(parsed.data); 
        currentFrame = "config";  // Reset safely
        updateCurrentFrameLabel(); // ✅ Add this
        console.log("Built tabs");
        createBoxes(parsed.data.frames[currentFrame]); 
      }
      else if (parsed.cmd === "list_frames" && parsed.files) {
        popupFileList(parsed.files, parsed.requestor || "load");
      }
      else if (parsed.cmd === "save_done") {
        if (parsed.status === "ok") {
          popup("Save Successful ✅", true);
        } else {
          popup("Save Failed ❌: " + (parsed.error || "Unknown Error"), false);
        }
      }
      else if (parsed.cmd === 'data_set_values') {
        //console.log("got values");
        applyIncomingValues(parsed.values);
      }

       // Future: can add confirmation messages for save/saveas
    }
    catch (e) { 
      console.error("Parsing WS failed:", e); 
    }
  };
  socket.onerror = () => { 
    updateConnectionStatus(false);
    console.warn("WebSocket error"); 
    popup("WebSocket Error ❌", false);
  };
  socket.onclose = () => { 
    updateConnectionStatus(false);
    popup("WebSocket Disconnected ❌", false);
    document.getElementById('pollingButton').disabled = true;
    pollingActive = false;
    stopPollingData();
    document.getElementById('pollingButton').textContent = "Start Polling";
    if (!connected) { 
      liveData = null; 
      frameData = fakeData,data;
      initializeAllFrames(frameData);

      frameData.dataSets = buildDataSets(frameData);
      register_dataSets(frameData.dataSets);

      buildTabs(frameData); 
      createBoxes(frameData.frames[currentFrame]); 
    }
  };
}

// Start
  frameData = fakeData.data;
  currentFrame = "config";  // Reset safely
  reloadData();  // cleaner
  connectWebSocket();
</script>


<div id="contextMenu" style="display:none; position:absolute; background:white; border:1px solid black; z-index:1000;">
  <div onclick="deleteField()">Delete Field</div>
  <div onclick="editField()">Edit Field</div>
  <div onclick="addFieldBefore()">Add Field Before</div>
  <div onclick="addFieldAfter()">Add Field After</div>
</div>
<div id="fieldPopup" style="display:none; position:fixed; top:30%; left:30%; width:300px; background:white; border:2px solid black; padding:20px; z-index:1001;">
  <h3>New Field Setup</h3>
  <label>Name:</label><br>
  <input id="popupFieldName" type="text"><br><br>

  <label>Default Value:</label><br>
  <input id="popupFieldDefault" type="text"><br><br>

  <label><input id="popupFieldInput" type="checkbox" checked> Input Field (editable)</label><br><br>

  <button onclick="confirmNewField()">Confirm</button>
  <button onclick="cancelNewField()">Cancel</button>
</div>

</body>
</html>