<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Alarm Config Editor</title>
    <style>
        /* Reset and base styles */
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 0;
        }

        /* Header styles */
        header {
            background: #222;
            color: #eee;
            padding: 10px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        header h1 {
            margin: 0;
            font-size: 18px;
        }

        header .controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        header input[type="text"] {
            padding: 4px 6px;
            font-size: 12px;
        }

        header button {
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        /* Tabs styles */
        .tabs {
            display: flex;
            border-bottom: 1px solid #ccc;
            background: #f0f0f0;
        }

        .tab {
            padding: 8px 12px;
            cursor: pointer;
            border-right: 1px solid #ccc;
        }

        .tab.active {
            background: #fff;
            border-bottom: 2px solid #007bff;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            padding: 10px;
            overflow: auto;
            max-height: calc(100vh - 150px);
        }

        .tab-content.active {
            display: block;
        }

        /* Tab controls */
        .tab-controls {
            margin-bottom: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tab-controls button {
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        /* Table styles */
        table {
            border-collapse: collapse;
            width: 100%;
            font-size: 12px;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 4px 6px;
            text-align: left;
            white-space: nowrap;
        }

        th {
            background: #f9f9f9;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        tbody tr:nth-child(even) {
            background: #fafafa;
        }

        tbody tr.new-row {
            background: #e8f5e9;
        }

        tbody tr.deleted-row {
            background: #ffebee;
            text-decoration: line-through;
            opacity: 0.6;
        }

        td[contenteditable="true"] {
            background: #fffef0;
        }

        td[contentselect="true"] {
            background: #fffef0;
        }

        td select {
            width: 100%;
            padding: 0;
            margin: 0;
            border: none;
            background-color: transparent;
            font-family: inherit;
            font-size: inherit;
            color: inherit;
            line-height: inherit;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            cursor: pointer;
            box-sizing: border-box;
        }

        td select:focus {
            outline: none;
        }

        /* Selectable cell styles */
        td.selectable-cell {
            position: relative;
            padding-right: 16px;
            color: #413404;
            cursor: pointer;
        }

        td.selectable-cell::after {
            content: "â–¼";
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 9px;
            color: #d4ac0d;
            pointer-events: none;
        }

        td.selectable-cell:hover::after {
            color: #b7950b;
        }

        /* Action cell styles */
        td.action-cell {
            text-align: left;
        }

        td.action-cell button {
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }

        /* Status bar styles */
        .status-bar {
            padding: 6px 10px;
            background: #f8f8f8;
            border-top: 1px solid #ddd;
            font-size: 11px;
            color: #555;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .status-bar span {
            margin-right: 15px;
        }

        .status-ok {
            color: #0a0;
        }

        .status-error {
            color: #a00;
        }

        /* Target tab specific styles */
        .target-section, .target-connection-section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fafafa;
        }

        .target-section h3, .target-connection-section h3 {
            margin-top: 0;
            font-size: 14px;
            color: #333;
        }

        .target-section label, .target-connection-section label {
            font-size: 12px;
        }

        .target-section input[type="text"], .target-section input[type="number"],
        .target-connection-section input[type="text"], .target-connection-section input[type="number"] {
            padding: 4px 6px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .target-section input[type="checkbox"], .target-connection-section input[type="checkbox"] {
            margin-left: 4px;
        }

        .target-section button, .target-connection-section button {
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-right: 8px;
        }

        #targetVarsTable td[contenteditable="true"] {
            background: #fffef0;
            cursor: text;
        }

        /* Modal backdrop */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
        }

        /* JSON Modal styles */
        #jsonModal {
            display: none;
            position: fixed;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            background: #fff8b3; /* soft yellow */
            border: 2px solid #f1c40f; /* golden yellow border */
            border-radius: 12px; /* rounded corners */
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            overflow: auto;
            z-index: 1000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #jsonEditor {
            width: 100%;
            height: 70%;
            font-family: monospace;
            font-size: 14px;
            border: 1px solid #f1c40f;
            border-radius: 8px;
            padding: 10px;
            background-color: #fffde7; /* lighter yellow */
            resize: vertical;
        }

        #saveJsonBtn, #cancelJsonBtn {
            background-color: #f1c40f;
            border: none;
            color: #333;
            padding: 8px 16px;
            margin-right: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease;
        }

        #saveJsonBtn:hover, #cancelJsonBtn:hover {
            background-color: #d4ac0d;
        }

        /* Limits structure and definition cells */
        .limits-structure-cell, .limits-def-cell {
            background-color: #fffde7; /* light golden yellow */
            cursor: pointer;
            border-radius: 6px;
            padding: 4px 8px;
            color: #333; /* dark text for contrast */
        }

        .limits-def-cell:hover, .limits-structure-cell:hover {
            background-color: #dbb20c; /* slightly darker on hover */
        }

        /* Limits table input number styling */
        #limitsTable input[type="number"] {
            width: 60px; /* or whatever width fits your layout */
            padding: 2px 4px;
            font-size: 12px;
        }

        /* Modal styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            width: 400px;
        }

        .close {
            float: right;
            cursor: pointer;
            font-size: 24px;
        }

        .nice-modal {
            display: none;
            position: fixed;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            background: #fff8b3; /* soft yellow */
            border: 2px solid #f1c40f; /* golden yellow border */
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            overflow: auto;
            z-index: 1000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .nice-modal textarea {
            width: 100%;
            height: 70%;
            font-family: monospace;
            font-size: 14px;
            border: 1px solid #f1c40f;
            border-radius: 8px;
            padding: 10px;
            background-color: #fffde7;
            resize: vertical;
        }

        .nice-modal .buttons {
            margin-top: 15px;
            text-align: right;
        }

        .nice-modal button {
            background-color: #fffde7;
            border: none;
            color: #333;
            padding: 8px 16px;
            margin-left: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease;
        }

        .nice-modal button:hover {
            background-color: #d4ac0d;
        }

        .actions-cell-highlight {
            background-color: #d4ac0d; /* darker golden yellow */
            cursor: pointer;
            border-radius: 6px;
            padding: 4px 8px;
            color: #333;
            text-align: center;
        }

        .actions-cell-highlight:hover {
            background-color: #dbbc3d; /* slightly darker on hover */
        }
    </style>
</head>
<body>
<header>
    <h1>Alarm Config Editor ver 18</h1>
    <div class="controls">
        <label>Project: <input type="text" id="projectInput" value="hithium"></label>
        <label>Version: <input type="text" id="versionInput" value="0.42.1"></label>
        <button id="loadBtn">Load Config</button>
        <button id="saveBtn">Save Config</button>
        <button id="exportBtn">Export JSON</button>
        <button id="importBtn">Import JSON</button>
    </div>
</header>

<div id="modalBackdrop" class="modal-backdrop"></div>

<div class="tabs">
    <div class="tab active" data-target="tab-defs">alarm_definitions</div>
    <div class="tab" data-target="tab-levels">alarm_level_actions</div>
    <div class="tab" data-target="tab-limits">limits_values</div>
    <div class="tab" data-target="tab-target">target</div>
</div>

<div id="tab-defs" class="tab-content active">
    <div class="tab-controls">
        <button id="addAlarmBtn">âž• Add Alarm</button>
        <span style="color: #666; font-size: 11px;">Click "Delete" on a row to mark for deletion. Save to apply changes.</span>
    </div>
    <table id="defsTable">
        <thead>
            <tr>
                <th>alarm_num</th>
                <th>alarm_name</th>
                <th>num_levels</th>
                <th>measured_variable</th>
                <th>limits_def</th>
                <th>comparison_type</th>
                <th>alarm_variable</th>
                <th>latched_variable</th>
                <th>notes</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>

<div id="tab-levels" class="tab-content">
    <table id="levelsTable">
        <thead>
            <tr>
                <th>alarm_num</th>
                <th>alarm_name</th>
                <th>level</th>
                <th>enabled</th>
                <th>duration</th>
                <th>actions</th>
                <th>notes</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>

<div id="tab-limits" class="tab-content">
    <div id="limitsValuesTargetConnection" class="target-connection-section">

        <!-- <div class="target-section"> Limits Tab -->
        <h3>Target Connection</h3>
        <div class="target-form">
            <label>IP: <input type="text" id="limitsTargetIp" value="192.168.86.209" /></label>
            <label>Port: <input type="number" id="limitsTargetPort" value="9001" /></label>
            <label>Secure: <input type="checkbox" id="limitsTargetSecure" /></label>
            <button id="saveLimitsTargetConfigBtn">ðŸ’¾ Save Config</button>
            <button id="loadLimitsTargetConfigBtn">ðŸ”„ Load Config</button>
        </div>
   
        <div>
            <button id="limitsGetAllBtn">Get All Limits</button>
            <button id="limitsSetAllBtn">Set All Limits</button>
        </div>
    </div>
    <table id="limitsTable">
        <thead>
            <tr>
                <th>name</th>
                <th>level1_limit</th>
                <th>level2_limit</th>
                <th>level3_limit</th>
                <th>hysteresis</th>
                <th>target_level1</th>
                <th>target_level2</th>
                <th>target_level3</th>
                <th>target_hysteresis</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>


<!-- Edit Actions Model -->
<div id="jsonModal" class="modal" 
         style="display:none; position:fixed; top:10%; left:10%; width:80%; height:80%; 
          background:#fff; border:1px solid #ccc; padding:20px; overflow:auto; z-index:1000;">
    <span class="close" style="float:right; font-size:24px; cursor:pointer;" onclick="closeJsonModal()">&times;</span>
  <h3>Edit Actions JSON</h3>
  <textarea id="jsonEditor" style="width:100%; height:70%; font-family: monospace;"></textarea>
  <br/>
  <button id="saveJsonBtn">Save</button>
  <!-- <button id="cancelJsonBtn">Cancel</button> -->
</div>

<!-- Limit Definition Editor Modal -->
<div id="limitDefModal" class="modal" style="display:none; position:fixed; top:10%; left:10%; width:80%; height:80%; background:#fff; border-radius:12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding:20px; z-index:1000; font-family: 'Courier New', Courier, monospace;">
  <span class="close" style="position:absolute; top:12px; right:16px; font-size:28px; font-weight:bold; cursor:pointer;" onclick="closeLimitDefModal()">&times;</span>
  <h3 style="margin-top:0; margin-bottom:16px;">Edit Limit Definition</h3>

  <form id="limitDefForm" style="display:flex; flex-direction:column; gap:12px;">
    <label style="display:flex; flex-direction:column; font-weight:bold;">
      Name:
      <input type="text" id="limitDefName" readonly style="padding:8px; font-family:inherit; border:1px solid #ccc; border-radius:6px;">
    </label>

    <label style="display:flex; flex-direction:column; font-weight:bold;">
      SM Name:
      <input type="text" id="limitDefSmName" style="padding:8px; font-family:inherit; border:1px solid #ccc; border-radius:6px;">
    </label>

    <label style="display:flex; flex-direction:column; font-weight:bold;">
      Reg Type:
      <input type="text" id="limitDefRegType" style="padding:8px; font-family:inherit; border:1px solid #ccc; border-radius:6px;">
    </label>

    <label style="display:flex; flex-direction:column; font-weight:bold;">
      Offset:
      <input type="text" id="limitDefOffset" style="padding:8px; font-family:inherit; border:1px solid #ccc; border-radius:6px;">
    </label>

    <label style="display:flex; flex-direction:column; font-weight:bold;">
      Num:
      <input type="number" id="limitDefNum" style="padding:8px; font-family:inherit; border:1px solid #ccc; border-radius:6px;">
    </label>

    <label style="display:flex; flex-direction:column; font-weight:bold;">
      Defs:
      <input type="text" id="limitDefs" style="padding:8px; font-family:inherit; border:1px solid #ccc; border-radius:6px;">
    </label>
    <div style="margin-top:12px;">
      <button type="button" id="saveLimitDefBtn" style="background-color:#d4ac0d; border:none; border-radius:6px; padding:8px 16px; color:#333; font-weight:600; cursor:pointer;">Save</button>
    </div>
  </form>
</div>


<!-- Limits Modal -->
<div id="limitsModal" class="modal" style="display:none; position:fixed; top:10%; left:10%; width:80%; height:80%; background:#fff; border:1px solid #ccc; padding:20px; overflow:auto; z-index:1000; border-radius: 12px;">
 <span class="close" style="float:right; font-size:24px; cursor:pointer;" onclick="closeLimitsModal()">&times;</span>
  <h3>Edit Limit Definitions</h3>
  <pre id="limitsModalContent" style="background:#f9f9f9; padding:10px; border-radius:8px; height:60%; overflow:auto; font-family: monospace;"></pre>
  <div style="margin-top: 10px;">
    <button id="getTargetBtn">Get Target</button>
    <button id="setTargetBtn">Set Target</button>
    <button id="getLimitsBtn">Get Def</button>
    <button id="updateLimitsBtn">Update Limit Def</button>
    <button id="saveLimitsBtn">Save</button>
    <button id="saveLimitsAsBtn">Save as</button>
    <!-- <button id="cancelLimitsBtn">Cancel</button> -->
  </div>
</div>
 <div id="modalBackdrop" class="modal-backdrop" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:999;"></div>
<div id="limitsModal" class="modal" style="display:none; position:fixed; top:10%; left:10%; width:80%; height:80%; background:#fff; border:1px solid #ccc; padding:20px; overflow:auto; z-index:1000; border-radius: 12px;">
  <span class="close" style="float:right; font-size:24px; cursor:pointer;" onclick="closeLimitsModal()">&times;</span>
  <h3>Edit Limit Definitions</h3>
  <pre id="limitsModalContent" style="background:#f9f9f9; padding:10px; border-radius:8px; height:60%; overflow:auto; font-family: monospace;"></pre>
  <div style="margin-top: 10px;">
    <button id="getTargetBtn">Get Target</button>
    <button id="setTargetBtn">Set Target</button>
    <button id="getLimitsBtn">Get Def</button>
    <button id="updateLimitsBtn">Update Limit Def</button>
    <button id="saveLimitsBtn">Save</button>
    <button id="saveLimitsAsBtn">Save as</button>
  </div>
</div>

<div id="tab-target" class="tab-content">
    <div class="target-section">
        <h3>Target Connection</h3>
        <div class="target-form">
            <label>IP: <input type="text" id="targetIp" value="127.0.0.1" /></label>
            <label>Port: <input type="number" id="targetPort" value="8080" /></label>
            <label>Secure: <input type="checkbox" id="targetSecure" /></label>
            <button onclick="saveTargetConfig()">ðŸ’¾ Save Config</button>
            <button onclick="loadTargetConfig()">ðŸ”„ Load Config</button>
        </div>
    </div>

    <div class="target-section">
        <h3>Variable Get/Set</h3>

        <!-- Var list selection row -->
        <div class="tab-controls">
            <label style="font-size: 12px;">
                Files List:
                <select id="varListSelect" style="font-size: 12px; padding: 2px 4px; min-width: 160px;">
                    <!-- options filled by JS -->
                </select>
            </label>
            <label style="font-size: 12px;">
                 Json List:
                <select id="jsonDefSelect" style="font-size: 12px; padding: 2px 4px; min-width: 160px;">
                    <!-- options filled by JS -->
                </select>
            </label>
            <button onclick="reloadListOptions()">ðŸ”„ Refresh Lists</button>
            <button id="loadListBtn" onclick="loadSelectedVarList()">ðŸ“‚ Load List</button>
            <button id="saveListBtn" onclick="saveVarList()">ðŸ’¾ Save List</button>
            <button onclick="getAllTarget()">ðŸ“¥ Get All</button>
            <button onclick="setAllTarget()">ðŸ“¤ Save All</button>
        </div>

        <!-- Row-level and bulk operations -->
        <div class="tab-controls">
            <button onclick="addTargetVar()">âž• Add Variable</button>
            <span style="color: #666; font-size: 11px;">Type variable name or shared mem ref, then click Get/Set.</span>
        </div>

        <table id="targetVarsTable">
            <thead>
                <tr>
                    <th>Variable Name / Ref</th>
                    <th>sm_name</th>
                    <th>reg_type</th>
                    <th>offset</th>
                    <th>num</th>
                    <th>write data</th>
                    <th>read data</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<div class="status-bar">
    <span id="statusText">Ready.</span>
</div>

<script>


const loadListBtn = document.getElementById('loadListBtn');
const saveListBtn = document.getElementById('saveListBtn');
const jsonSelect = document.getElementById('jsonDefSelect');
const fileInput = document.getElementById('varListSelect');

function updateLoadButtonText() {
  if (fileInput.value) {
    loadListBtn.textContent = 'ðŸ“‚ Load File';
    saveListBtn.textContent = 'ðŸ“‚ Save File';
  } else if (jsonSelect.value) {
    loadListBtn.textContent = 'ðŸ“‚ Load JSON';
    saveListBtn.textContent = 'ðŸ“‚ Save JSON';
  } else {
    loadListBtn.textContent = 'ðŸ“‚ Load List';
    saveListBtn.textContent = 'ðŸ“‚ Save List';
  }
}

jsonSelect.addEventListener('change', () => {
  if (jsonSelect.value) {
    fileInput.value = ''; // Clear file input if JSON selected
  }
  updateLoadButtonText();
});

fileInput.addEventListener('change', () => {
  if (fileInput.value) {
    jsonSelect.value = ''; // Clear JSON select if file selected
  }
  updateLoadButtonText();
});

let alarmDefsData = []; // This will be populated when you load the data
let limitsDefsData = []; // This will be populated when you load the data
let limitsDefsMap = new Map(); // This will be populated when you load the data
let limitsDefList= []; // This is the list of limits_def items cool this worls
const apiBase = location.origin + '/api/alarms';
const pubApiBase = location.origin + '/api/pub_defs';

const COMPARISON_OPTIONS = [
    'greater_than',
    'less_than',
    'equal',
    'not_equal',
    'greater_or_equal',
    'less_or_equal',
    'aggregate'
];

function makeComparisonTypeEditable(td) {
    if (td.querySelector('select')) return;

    const current = (td.textContent || '').trim() || 'greater_than';

    const select = document.createElement('select');
    COMPARISON_OPTIONS.forEach(opt => {
        const o = document.createElement('option');
        o.value = opt;
        o.textContent = opt;
        if (opt === current) o.selected = true;
        select.appendChild(o);
    });

    td.textContent = '';
    td.appendChild(select);
    select.focus();
    // Flag to prevent double removal
    let removed = false;

    const finalize = () => {
        if (removed) return;
        removed = true;
        const value = select.value;
        td.removeChild(select);
        td.textContent = value;
    };

    // select.addEventListener('blur', finalize);
    // select.addEventListener('change', finalize);
    select.addEventListener('blur', () => {
        // Delay to allow 'change' event to fire first
        setTimeout(finalize, 100);
    });
  
    select.addEventListener('change', () => {
        finalize();
    });
}

function setStatus(msg, isError = false) {
    const el = document.getElementById('statusText');
    el.textContent = msg;
    el.className = isError ? 'status-error' : 'status-ok';
}

// Simple tab switching
document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.target).classList.add('active');
    });
});

// Render helpers
// Alarm Definitions tab
function renderDefs(data) {
    const tbody = document.querySelector('#defsTable tbody');
    tbody.innerHTML = '';
    data.forEach(row => {
        const tr = document.createElement('tr');
        const cols = ['alarm_num','alarm_name','num_levels','measured_variable','limits_def','comparison_type','alarm_variable','latched_variable','notes'];
        cols.forEach(col => {
            const td = document.createElement('td');
            if (col === 'limits_def') {
                // Show limit_defs.name if available, else fallback to limits_structure string
                td.textContent = row.limits_def; // && row.limit_defs.name) || row.limits_structure || '';
            } else {
                td.textContent = row[col] ?? '';
            }
            //td.textContent = row[col] ?? '';
            td.setAttribute('data-col', col);
            if (col !== 'alarm_num') {
                if (col === 'comparison_type') {
                    td.classList.add('selectable-cell');
                    td.addEventListener('click', () => makeComparisonTypeEditable(td));
                    td.setAttribute('contentselect', 'true');
                } else {
                    td.setAttribute('contenteditable', 'true');
                }
            }
            tr.appendChild(td);
        });

        const actionTd = document.createElement('td');
        actionTd.className = 'action-cell actions-cell-highlight';
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'ðŸ—‘ï¸ Delete';
        deleteBtn.onclick = () => toggleDeleteRow(tr);
        actionTd.appendChild(deleteBtn);
        tr.appendChild(actionTd);

        tbody.appendChild(tr);
    });
    function attachLimitsStructureClickHandlers() {
        document.querySelectorAll('#defsTable tbody tr td[data-col="limits_def"]').forEach(cell => {
            cell.classList.add('limits-def-cell');
            cell.addEventListener('click', () => openLimitsModal(cell));
        });
    }
    attachLimitsStructureClickHandlers()
}

function renderLevels(data) {
    const tbody = document.querySelector('#levelsTable tbody');
    tbody.innerHTML = '';
    data.forEach(row => {
        const tr = document.createElement('tr');
        const cols = ['alarm_num','alarm_name','level','enabled','duration','actions','notes'];
        cols.forEach(col => {
            const td = document.createElement('td');
            let val = row[col];
            if (col === 'actions') {
                td.className = 'action-cell actions-cell-highlight';
            }
            
            if (col === 'enabled') {
                val = row[col] ? 1 : 0;
            }
            td.textContent = val ?? '';
            td.setAttribute('data-col', col);
            if (col !== 'alarm_num' && col !== 'alarm_name' && col !== 'level') {
                td.setAttribute('contenteditable', 'true');
            }
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    });
    document.querySelectorAll('#levelsTable tbody tr td[data-col="actions"]').forEach(cell => {
        cell.style.cursor = 'pointer';
        cell.addEventListener('click', () => openJsonModal(cell));
    });

}
let limitsTargetConnected = false;
let currentLimitsValues = [];

function updateLimitsTargetUI() {
    document.getElementById('limitsConnectionStatus').textContent = limitsTargetConnected ? 'Connected' : 'Disconnected';
    document.getElementById('limitsConnectBtn').disabled = limitsTargetConnected;
    document.getElementById('limitsDisconnectBtn').disabled = !limitsTargetConnected;
    document.getElementById('limitsGetAllBtn').disabled = !limitsTargetConnected;
    document.getElementById('limitsSetAllBtn').disabled = !limitsTargetConnected;
}

document.getElementById('limitsGetAllBtn').addEventListener('click', async () => {
    //if (!limitsTargetConnected) return alert('Not connected');
    await getAllLimitValues();
});

document.getElementById('limitsSetAllBtn').addEventListener('click', async () => {
    //if (!limitsTargetConnected) return alert('Not connected');
    await setAllLimitValues();
});
// --- Limits Values Table Population ---
function populateLimitsValuesTable() {
    const tbody = document.querySelector('#limitsTable tbody');
    tbody.innerHTML = ''; // Clear existing rows

    // Convert Map to array of items
    const items = Array.from(limitsDefsMap.values());

    items.forEach((item, index) => {
        const tr = document.createElement('tr');
        tr.dataset.index = index;

        // Use default 0 if not defined
        const level1 = item.write_data[0] ?? 0;
        const level2 = item.write_data[1] ?? 0;
        const level3 = item.write_data[2] ?? 0;
        const hyst   =  item.write_data[3] ?? 0;

        const target1 = item.read_data[0] ?? '';
        const target2 = item.read_data[1] ?? '';
        const target3 = item.read_data[2] ?? '';
        const target_hyst   =  item.read_data[3] ?? 0;

        tr.innerHTML = `
            <td class="limits-def-cell" onclick='openLimitDefModal(${JSON.stringify(item.name)}, ${index})'>${item.name ?? ''}</td>
            <td><input type="number" data-col="level1_limit" value="${level1}"></td>
            <td><input type="number" data-col="level2_limit" value="${level2}"></td>
            <td><input type="number" data-col="level3_limit" value="${level3}"></td>
            <td><input type="number" data-col="hysteresis" value="${hyst}"></td>
            <td><span data-col="target_level1">${target1}</span></td>
            <td><span data-col="target_level2">${target2}</span></td>
            <td><span data-col="target_level3">${target3}</span></td>
            <td><span data-col="target_hysteresis">${target_hyst}</span></td>
            <td class="action-cell">
                <button onclick='getLimitVals("${item.name}", ${index})'>ðŸ“¥ Get</button>
                <button onclick='setLimitVals("${item.name}", ${index})'>ðŸ“¤ Set</button>
            </td>
        `;

        tbody.appendChild(tr);
    });
}

document.getElementById('saveLimitDefBtn').addEventListener('click', closeLimitDefModal);


function populateJsonDefSelect() {
  const select = document.getElementById('jsonDefSelect');
  
  // Remove all existing options
  while (select.firstChild) {
    select.removeChild(select.firstChild);
  }
  
  // Add the default option
  const defaultOption = document.createElement('option');
  defaultOption.value = "";
  defaultOption.textContent = "-- Select a Limits Group --";
  select.appendChild(defaultOption);

  // Add the group options
  limitsDefList.forEach(groupName => {
    const option = document.createElement('option');
    option.value = groupName;
    option.textContent = groupName;
    select.appendChild(option);
  });
}

async function getLimitVals(limit_name, index) {

     const item = findLimitByPathName(limitsDefsMap, "alarm_limits", limit_name);

    console.log(" limit_def ", item);

    if (!item) return;

    const ip = document.getElementById('limitsTargetIp').value;
    const port = document.getElementById('limitsTargetPort').value;
    const secure = document.getElementById('limitsTargetSecure').checked;

    const payload = {
        sm_name: item.sm_name,
        reg_type: item.reg_type,
        offset: item.offset,
        num: item.num
    };

    setStatus('Getting data from target...');

    try {
        const res = await fetch(apiBase + '/target/get', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
            });
        const data = await res.json();
        console.log(" got data :", data);
        if (!res.ok) throw new Error(data.error || ('HTTP ' + res.status));

        item.read_data = data.read_data || [];

        // Update UI accordingly...
        // Update target fields in UI
        const tr = document.querySelector(`#limitsTable tbody tr[data-index="${index}"]`);
        if (tr) {
            tr.querySelector('span[data-col="target_level1"]').textContent =  data.read_data[0] ?? '';
            tr.querySelector('span[data-col="target_level2"]').textContent = data.read_data[1] ?? '';
            tr.querySelector('span[data-col="target_level3"]').textContent = data.read_data[2] ?? '';
            tr.querySelector('span[data-col="target_hysteresis"]').textContent = data.read_data[3] ?? '';
        }

        setStatus('Got data: ' + JSON.stringify(data), false);
    } catch (err) {
        console.error(err);
        setStatus('Error getting data: ' + err.message, true);
    }
}

async function setLimitVals(limit_name, index) {

    const item = findLimitByPathName(limitsDefsMap, "alarm_limits", limit_name);

    console.log(" limit_def ", item);

    if (!item) return;


    const tr = document.querySelector(`#limitsTable tbody tr[data-index="${index}"]`);
    if (!tr) {
        console.warn(`Table row not found for index ${index}`);
        return;
    }

    // Collect values from inputs in the row
    const level1 = Number(tr.querySelector('input[data-col="level1_limit"]').value);
    const level2 = Number(tr.querySelector('input[data-col="level2_limit"]').value);
    const level3 = Number(tr.querySelector('input[data-col="level3_limit"]').value);
    const hysteresis = Number(tr.querySelector('input[data-col="hysteresis"]').value);

    const ip = document.getElementById('limitsTargetIp').value;
    const port = document.getElementById('limitsTargetPort').value;
    const secure = document.getElementById('limitsTargetSecure').checked;

    const payload = {
        sm_name: item.sm_name,
        reg_type: item.reg_type,
        offset: item.offset,
        write_data: [level1, level2, level3, hysteresis]
    };

    setStatus('Setting data on target...');

    try {
        const res = await fetch(apiBase + '/target/set', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
            });
 
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || ('HTTP ' + res.status));

        // Update write_data in the map
        item.write_data = payload.write_data;

        setStatus('Set data success: ' + JSON.stringify(data), false);
    } catch (err) {
        console.error(err);
        setStatus('Error setting data: ' + err.message, true);
    }
}

async function getLimitValue(alarmNum) {
    try {
        const res = await fetch(`${apiBase}/target/limits/${alarmNum}`);
        if (!res.ok) throw new Error('Failed to get limit value');
        const data = await res.json();

        const index = currentLimitsValues.findIndex(lv => lv.alarm_num === alarmNum);
        if (index !== -1) {
            currentLimitsValues[index] = { ...currentLimitsValues[index], ...data };
            renderLimitsValuesTable();
        }
    } catch (err) {
        alert('Error getting limit value: ' + err.message);
    }
}

function updateLimitsValuesForAlarm(alarmNum) {
    // Collect the limits from the DOM
    const newLimits = collectLimitsForAlarm(alarmNum);
    if (!newLimits) {
        console.warn(`No limits found for alarmNum ${alarmNum}`);
        return;
    }

    // Find the index in currentLimitsValues
    const index = currentLimitsValues.findIndex(lv => lv.alarm_num === alarmNum);
    if (index === -1) {
        console.warn(`Alarm number ${alarmNum} not found in currentLimitsValues`);
        return;
    }

    // Preserve existing target values if present
    const existing = currentLimitsValues[index];
    currentLimitsValues[index] = {
        alarm_num: alarmNum,
        level1_limit: newLimits.level1_limit,
        level2_limit: newLimits.level2_limit,
        level3_limit: newLimits.level3_limit,
        hysteresis: newLimits.hysteresis,
        target_level1: existing.target_level1 !== undefined ? existing.target_level1 : null,
        target_level2: existing.target_level2 !== undefined ? existing.target_level2 : null,
        target_level3: existing.target_level3 !== undefined ? existing.target_level3 : null,
        target_hysteresis: existing.target_hysteresis !== undefined ? existing.target_hysteresis : null,
    };
}

function collectLimitsForAlarm(alarmNum) {
    const tr = document.querySelector(`#limitsTable tr[data-index='${alarmNum}']`);
    if (!tr) return null;

    return {
        alarm_num: alarmNum,
        level1_limit: Number(tr.querySelector('input[data-col="level1_limit"]').value),
        level2_limit: Number(tr.querySelector('input[data-col="level2_limit"]').value),
        level3_limit: Number(tr.querySelector('input[data-col="level3_limit"]').value),
        hysteresis: Number(tr.querySelector('input[data-col="hysteresis"]').value),
    };
}

async function setLimitValue(alarmNum) {
    try {
        updateLimitsValuesForAlarm(alarmNum);
        const limits = collectLimitsForAlarm(alarmNum);
        if (!limits) throw new Error('No limits data found');

        const res = await fetch(`${apiBase}/target/limits/${alarmNum}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(limits)
        });
        if (!res.ok) throw new Error('Failed to set limit value');
        alert('Limit value set successfully');
    } catch (err) {
        alert('Error setting limit value: ' + err.message);
    }
}

async function getAllLimitValues() {
    const table = document.querySelector('#limitsTable tbody');
    const rows = table.querySelectorAll('tr');

    for (const row of rows) {
        const index = row.dataset.index;
        const nameCell = row.querySelector('td:nth-child(2)'); // Adjust selector if needed
        const limitName = nameCell ? nameCell.textContent.trim() : null;

        if (limitName) {
            try {
                await getLimitVals(limitName, index);
            } catch (err) {
                console.error(`Error getting limit for ${limitName}:`, err);
            }
        }
    }

    setStatus('All limit values fetched.', false);
}

function collectAllLimits() {
    const limits = [];
    document.querySelectorAll('#limitsTable tbody tr').forEach(tr => {
        const alarmNum = Number(tr.dataset.alarmNum);
        limits.push(collectLimitsForAlarm(alarmNum));
    });
    return limits;
}

async function setAllLimitValues() {
    try {
        const limits = collectAllLimits();
        const res = await fetch(`${apiBase}/target/limits`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(limits)
        });
        if (!res.ok) throw new Error('Failed to set all limit values');
        alert('All limit values set successfully');
    } catch (err) {
        alert('Error setting all limit values: ' + err.message);
    }
}

// do we use this
function renderLimitsValuesTable() {
    const tbody = document.querySelector('#limitsTable tbody');
    tbody.innerHTML = '';
    currentLimitsValues.forEach(lv => {
        const tr = document.createElement('tr');
        tr.dataset.alarmNum = lv.alarm_num;

        tr.innerHTML = `
            <td class="limits-def-cell">${lv.name || ''}</td>
            <td><input type="number" data-col="level1_limit" value="${lv.level1_limit || 0}"></td>
            <td><input type="number" data-col="level2_limit" value="${lv.level2_limit || 0}"></td>
            <td><input type="number" data-col="level3_limit" value="${lv.level3_limit || 0}"></td>
            <td><input type="number" data-col="hysteresis" value="${lv.hysteresis || 0}"></td>
            <td><span data-col="target_level1">${lv.target_level1 || ''}</span></td>
            <td><span data-col="target_level2">${lv.target_level2 || ''}</span></td>
            <td><span data-col="target_level3">${lv.target_level3 || ''}</span></td>
            <td><span data-col="target_hysteresis">${lv.target_hysteresis || ''}</span></td>
            <td>
                <button onclick="getLimitValue(${lv.name})">Get</button>
                <button onclick="setLimitValue(${lv.name})">Set</button>
            </td>
        `;

        tbody.appendChild(tr);
    });
}

function renderLimits(data) {
    const tbody = document.querySelector('#limitsTable tbody');
    tbody.innerHTML = '';
    data.forEach(row => {
        const tr = document.createElement('tr');
        const cols = ['limits_structure','alarm_name','level1_limit','level2_limit','level3_limit','hysteresis','last_updated','notes'];
        cols.forEach(col => {
            const td = document.createElement('td');
            td.textContent = row[col] ?? '';
            td.setAttribute('data-col', col);
            if (col !== 'limits_structure' && col !== 'alarm_name' && col !== 'last_updated') {
                td.setAttribute('contenteditable', 'true');
            }
            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    });
}

function addNewAlarm() {
    const tbody = document.querySelector('#defsTable tbody');
    const existingRows = tbody.querySelectorAll('tr:not(.deleted-row)');
    
    let maxAlarmNum = -1;
    existingRows.forEach(tr => {
        const numCell = tr.querySelector('td[data-col="alarm_num"]');
        if (numCell) {
            const num = parseInt(numCell.textContent);
            if (!isNaN(num) && num > maxAlarmNum) {
                maxAlarmNum = num;
            }
        }
    });
    const newAlarmNum = maxAlarmNum + 1;
    
    const tr = document.createElement('tr');
    tr.className = 'new-row';
    
    const cols = ['alarm_num','alarm_name','num_levels','measured_variable','limits_def','comparison_type','alarm_variable','latched_variable','notes'];
    const defaults = {
        alarm_num: newAlarmNum,
        alarm_name: 'New Alarm',
        num_levels: 1,
        measured_variable: '',
        limits_def: 'New Alarm',
        comparison_type: 'greater_than',
        alarm_variable: '',
        latched_variable: '',
        notes: ''
    };
    
    cols.forEach(col => {
        const td = document.createElement('td');
        td.textContent = defaults[col];
        td.setAttribute('data-col', col);
        if (col !== 'alarm_num') {
            td.setAttribute('contenteditable', 'true');
        }
        tr.appendChild(td);
    });
    
    const actionTd = document.createElement('td');
    actionTd.className = 'action-cell';
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'ðŸ—‘ï¸ Delete';
    deleteBtn.onclick = () => toggleDeleteRow(tr);
    actionTd.appendChild(deleteBtn);
    tr.appendChild(actionTd);
    
    tbody.appendChild(tr);
    setStatus('New alarm added. Edit and click "Save to DB" to persist.', false);
}

function toggleDeleteRow(tr) {
    if (tr.classList.contains('deleted-row')) {
        tr.classList.remove('deleted-row');
        setStatus('Row unmarked for deletion.', false);
    } else {
        tr.classList.add('deleted-row');
        setStatus('Row marked for deletion. Click "Save to DB" to apply.', false);
    }
}

function collectDefs() {
    const rows = [];
    document.querySelectorAll('#defsTable tbody tr:not(.deleted-row)').forEach(tr => {
        const obj = {};
        tr.querySelectorAll('td[data-col]').forEach(td => {
            const col = td.getAttribute('data-col');
            let val = td.textContent.trim();

            if (col === 'alarm_num' || col === 'num_levels') {
                val = val === '' ? null : Number(val);
            }

            obj[col] = (val === '' ? null : val);
        });

        if (obj.alarm_num == null) {
            console.warn('Skipping row without alarm_num:', obj);
            return;
        }
        if (!obj.alarm_name || obj.alarm_name.toString().trim() === '') {
            console.warn('Skipping row without alarm_name:', obj);
            return;
        }
        if (obj.num_levels == null || isNaN(obj.num_levels)) {
            console.warn('Skipping row without valid num_levels:', obj);
            return;
        }

        rows.push(obj);
    });
    return rows;
}

function collectLevels() {
    const rows = [];
    document.querySelectorAll('#levelsTable tbody tr').forEach(tr => {
        const obj = {};
        tr.querySelectorAll('td').forEach(td => {
            const col = td.getAttribute('data-col');
            if (col === 'alarm_name') return;
            
            let val = td.textContent.trim();
            if (col === 'alarm_num' || col === 'level') {
                val = val === '' ? null : Number(val);
            } else if (col === 'enabled') {
                val = val === '' ? false : (val === '1' || val.toLowerCase() === 'true');
            } else if (col === 'duration') {
                val = val === '' ? "5:5" : val;
            }
            obj[col] = val === '' ? null : val;
        });
        if (obj.alarm_num != null && obj.level != null) {
            rows.push(obj);
        }
    });
    return rows;
}

function collectLimits() {
    const rows = [];
    document.querySelectorAll('#limitsTable tbody tr').forEach(tr => {
        const obj = {};
        tr.querySelectorAll('td').forEach(td => {
            const col = td.getAttribute('data-col');
            if (col === 'alarm_name') return;
            
            let val = td.textContent.trim();
            if (['level1_limit','level2_limit','level3_limit','hysteresis'].includes(col)) {
                val = val === '' ? null : Number(val);
            }
            obj[col] = val === '' ? null : val;
        });
        if (obj.limits_structure) {
            rows.push(obj);
        }
    });
    return rows;
}

/**
 * Returns an array of strings representing all table names.
 * @param {Array} data - The nested limitsDefsMap array.
 * @returns {Array<string>} - e.g., ["target_vars", "system_vars", "cell_limits"]
 */
/*
    Usage Examples (2025 Standard)
    1. Basic List:
    javascript
    const tables = getTableNames(limitsDefsMap);
    console.log(tables); // ["target_vars", "rtos_limits", ...]
    Use code with caution.

    2. Populating a Dropdown (HTML):
    If you want to use this list to fill a <select> menu in your UI:
    javascript
    const selectMenu = document.getElementById('tableSelect');
    const tables = getTableNames(limitsDefsMap);

    selectMenu.innerHTML = tables
        .map(name => `<option value="${name}">${name}</option>`)
        .join('');
*/

function getTableNames(data) {
    return data.map(entry => entry.table);
}

function buildLimitsDefNestedFromMap() {
    const grouped = {};

    for (const [key, item] of limitsDefsMap.entries()) {
        // key format: "table:name"
        const [table, name] = key.split(':');
        if (!grouped[table]) grouped[table] = [];
        grouped[table].push(item);
    }

    // Convert grouped object to array of {table, items}
    return Object.entries(grouped).map(([table, items]) => ({
        table,
        items
    }));
}

async function loadFromConfig() {
    setStatus('Loading from /api/alarms/config ...');
    try {
        const res = await fetch(apiBase + '/config');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        alarmDefsData = data.alarm_definitions || [];
        limitsDefsData = data.limits_def || [];
        // In your fetchConfig or where you process the config data:
        data.limits_def.forEach(tableGroup => {
            const tableName = tableGroup.table;
            limitsDefList.push(tableName);
            tableGroup.items.forEach(item => {
                limitsDefsMap.set(`${tableName}:${item.name}`, item);
            });
        });
        renderDefs(data.alarm_definitions || []);
        renderLevels(data.alarm_level_actions || []);
        renderLimits(data.limits_values || []);
        populateJsonDefSelect();
        populateLimitsValuesTable();
        
        setStatus('Loaded configuration from DB.', false);
    } catch (err) {
        console.error(err);
        setStatus('Error loading config: ' + err.message, true);
    }
}

async function savetoConfig() {
    const payload = {
        alarm_definitions: collectDefs(),
        alarm_level_actions: collectLevels(),
        limits_values: collectLimits(),
        limits_def: buildLimitsDefNestedFromMap()  // include updated limits_def
    };
    setStatus('Saving to /api/alarms/config ...');
    try {
        const res = await fetch(apiBase + '/config', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || ('HTTP ' + res.status));
        setStatus('Saved configuration to DB. Reloading...', false);
        await loadFromConfig();
    } catch (err) {
        console.error(err);
        setStatus('Error saving config: ' + err.message, true);
    }
}
// Helper function to build actions array for an alarm
function buildActionsForAlarm(alarmNum, alarmLevelActions) {
    // Filter actions for this specific alarm
    const actionsForThisAlarm = alarmLevelActions.filter(action => 
        action.alarm_num === alarmNum
    );
    
    // Sort by level and build the actions array
    return actionsForThisAlarm
        .sort((a, b) => a.level - b.level)
        .map(action => ({
            level: action.level,
            level_enabled: action.enabled,
            duration: action.duration || "2:3",
            actions: action.actions ? JSON.parse(action.actions) : [],
            notes: action.notes || ""
        }));
}

// Updated exportJSON function
async function exportJSON() {
    const projectDir = document.getElementById('projectInput').value.trim() || 'hithium';
    const version = document.getElementById('versionInput').value.trim() || '0.42.1';
    setStatus('Exporting JSON to dir: ' + projectDir + ', version: ' + version + ' ...');
    console.log('Exporting JSON to dir: ' + projectDir + ', version: ' + version + ' ...');


    // Collect current data
    const alarmDefinitions = collectDefs();
    const alarmLevelActions = collectLevels();
    const limitsValues = collectLimits();
    const limitsDef = buildLimitsDefNestedFromMap();
    console.log("limitsDef",limitsDef)

    // Build alarms array with embedded actions (matching original format)
    const alarms = alarmDefinitions.map(alarm => {
        // Build actions array for this alarm
        const actions = buildActionsForAlarm(alarm.alarm_num, alarmLevelActions);
        
        // Build limits array from limits_values
        let limitsArray = [0, 0, 0, 0];
        if (alarm.limits_structure) {
            const matchingLimit = limitsValues.find(lv => 
                lv.limits_structure === alarm.limits_structure
            );
            if (matchingLimit) {
                limitsArray = [
                    matchingLimit.level1_limit || 0,
                    matchingLimit.level2_limit || 0,
                    matchingLimit.level3_limit || 0,
                    matchingLimit.hysteresis || 0
                ];
            }
        }
        
        return {
            num: alarm.alarm_num,
            name: alarm.alarm_name,
            levels: alarm.num_levels,
            measured: alarm.measured_variable || "",
            limits: limitsArray,
            compare: alarm.comparison_type || "greater_than",
            alarm_var: alarm.alarm_variable || "",
            latch_var: alarm.latched_variable || "",
            limits_var: alarm.limits_structure || "",
            limits_def: alarm.limits_def || "",
            notes: alarm.notes || "",
            actions: actions  // Embedded actions array
        };
    });

    // Build the export config in the original format
    const config = {
        alarms: alarms,
        limits_def: limitsDef
    };

    try {
        const res = await fetch(apiBase + '/export-json', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ 
                directory: projectDir, 
                version: version,
                file_name: 'alarm_config.json', 
                config: config 
            })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || ('HTTP ' + res.status));
        setStatus('Exported JSON to: ' + data.message, false);
    } catch (err) {
        console.error(err);
        setStatus('Error exporting JSON: ' + err.message, true);
    }
}

async function importJSON() {
    const projectDir = document.getElementById('projectInput').value.trim() || 'hithium';
    const version = document.getElementById('versionInput').value.trim() || '0.42.1';
    setStatus('Importing JSON from dir: ' + projectDir + ', version: ' + version + ' ...');
    console.log('Importing JSON from dir: ' + projectDir + ', version: ' + version + ' ...');
    try {
        const res = await fetch(apiBase + '/import-json', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ directory: projectDir, version: version, file_name: 'alarm_config.json' })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || ('HTTP ' + res.status));
        setStatus('Imported JSON from: ' + projectDir + '. Reloading ...', false);
        await loadFromConfig();
    } catch (err) {
        console.error(err);
        setStatus('Error importing JSON: ' + err.message, true);
    }
}
// limits modal

let currentLimitsCell = null;
let currentLimitDefs = null;

function clearLimitsModal() {
  // Clear any input fields (e.g., limit labels)
  const inputs = document.querySelectorAll('#limitsModal input');
  inputs.forEach(input => {
    input.value = '';
  });

  // Clear the table content
  const modalContent = document.getElementById('limitsModalContent');
  if (modalContent) {
    modalContent.innerHTML = '';
  }
}

function openLimitsModal(cell) {
  currentLimitsCell = cell;
  const tr = cell.parentElement;
  const alarmNum = tr.querySelector('td[data-col="alarm_num"]').textContent.trim();
  const alarmName = tr.querySelector('td[data-col="alarm_name"]').textContent.trim();
  // Update modal header with alarm name
  document.querySelector('#limitsModal h3').textContent = `Edit Limit Definitions for "${alarmName}"`;

  // Find alarm data
  let alarmData = null;
  for (const alarm of alarmDefsData) {
    if (String(alarm.alarm_num) === alarmNum) {
      alarmData = alarm;
      break;
    }
  }
  if (!alarmData) {
    alert('Alarm data not found.');
    return;
  }

  // Find the alarm data in your global data model
  currentLimitDefs = null;
  currentLimitDefs = alarmData.limits_def || [];
  console.log('alarmNum :', alarmNum);
  console.log('alarmName :', alarmName);
  console.log('alarm Data :', alarmData);
  console.log('limit_defs :', currentLimitDefs);

  const modalContent = document.getElementById('limitsModalContent');
  modalContent.innerHTML = '';

  // Find the matching limits definition by alarmName
//      const existingDef = findLimitByPath(limitsDefsMap, "target_vars.online");
  const limitsDef = findLimitByPathName(limitsDefsMap, "alarm_limits", currentLimitDefs);
  //const limitsDef = limitsDefsMap.find(ld => ld.name === currentLimitDefs);
  console.log("limitsDef :", limitsDef);
  currentLimitDefs = limitsDef;
  if (!Array.isArray(currentLimitDefs)) {
        currentLimitDefs = [currentLimitDefs];
  }
  console.log("LimitDefs data:", currentLimitDefs);

  if (!limitsDef) {
    console.warn('No limits definition found for alarm:', alarmName);
    clearLimitsModal();
    return;
  }

  // Example: populate a label input if you have one
  if (document.getElementById('limit1_label')) {
    document.getElementById('limit1_label').value = limitsDef.limit1_label || '';
  }

  // Create table
  const table = document.createElement('table');
  table.classList.add('limits-table'); // add your CSS class if any

  // Table header
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  const columns = ['name', 'sm_name', 'reg_type', 'offset', 'num', 'write_data', 'read_data'];
  columns.forEach(col => {
    const th = document.createElement('th');
    th.textContent = col;
    headerRow.appendChild(th);
  });
  // Add action column header
  const actionTh = document.createElement('th');
  actionTh.textContent = 'Actions';
  headerRow.appendChild(actionTh);

  thead.appendChild(headerRow);
  table.appendChild(thead);

  // Table body
  const tbody = document.createElement('tbody');
  console.log(" current limit defs 2 :", currentLimitDefs);
  currentLimitDefs.forEach(item => {
    const tr = document.createElement('tr');

    columns.forEach(col => {
      const td = document.createElement('td');
      let cellValue = item[col];

      // For write_data and read_data, stringify arrays or objects
      if ((col === 'write_data' || col === 'read_data') && typeof cellValue !== 'string') {
        try {
          cellValue = JSON.stringify(cellValue || [], null, 2);
        } catch {
          cellValue = '';
        }

      } else if (cellValue == null) {
        cellValue = '';
      }

      td.textContent = cellValue;
      td.setAttribute('data-col', col);
      td.setAttribute('contenteditable', 'true');
      tr.appendChild(td);
    });

    // Actions cell with buttons
    const actionTd = document.createElement('td');
    actionTd.className = 'action-cell';

 
    const delBtn = document.createElement('button');
    delBtn.textContent = 'ðŸ—‘ï¸';
    delBtn.onclick = () => tr.remove();
    actionTd.appendChild(delBtn);

    tr.appendChild(actionTd);
    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  modalContent.appendChild(table);

  // Show modal and backdrop
  document.getElementById('limitsModal').style.display = 'block';
  document.getElementById('modalBackdrop').style.display = 'block';
}

function openLimitDefModal(limitName, index) {
  const items = Array.from(limitsDefsMap.values());
  const item = items[index];
  if (!item || item.name !== limitName) return;

  // Populate modal fields
  document.getElementById('limitDefName').value = item.name;
  document.getElementById('limitDefSmName').value = item.sm_name || '';
  document.getElementById('limitDefRegType').value = item.reg_type || '';
  document.getElementById('limitDefOffset').value = item.offset || '';
  document.getElementById('limitDefNum').value = item.num || '';
  document.getElementById('limitDefs').value = JSON.stringify(item.write_data || [], null, 2);

  // Show modal
  document.getElementById('limitDefModal').style.display = 'block';

  // Save reference to item for saving
  window.currentEditingItem = item;
  window.currentEditingIndex = index;
}

function closeLimitDefModal() {

  if (!window.currentEditingItem) {
    console.warn('No current editing item set');
    return;
  }

  const item = window.currentEditingItem;
  const index = window.currentEditingIndex;
  console.log('Closing modal for item:', item, 'at index:', index);

  // Read values from modal fields
  item.name = document.getElementById('limitDefName').value;
  item.sm_name = document.getElementById('limitDefSmName').value;
  item.reg_type = document.getElementById('limitDefRegType').value;
  item.offset = document.getElementById('limitDefOffset').value;
  item.num = document.getElementById('limitDefNum').value;

  try {
    item.write_data = JSON.parse(document.getElementById('limitDefs').value);
  } catch (e) {
    alert('Invalid JSON in write_data field: ' + e.message);
    return; // Don't close modal if JSON is invalid
  }

  // Update the map entry (assuming item.name is the key)
  limitsDefsMap.set(item.name, item);


  const row = document.querySelector(`#limitsTable tr[data-index="${index}"]`);
  console.log('Updating row for alarm num row:', index, row);
  if (row) {
    // Decode write_data array back into individual limit fields
    const writeData = item.write_data || [];
    const level1 = writeData.length > 0 ? writeData[0] : '';
    const level2 = writeData.length > 1 ? writeData[1] : '';
    const level3 = writeData.length > 2 ? writeData[2] : '';
    const hyst = writeData.length > 3 ? writeData[3] : '';

    row.querySelector('input[data-col="level1_limit"]').value = level1;
    row.querySelector('input[data-col="level2_limit"]').value = level2;
    row.querySelector('input[data-col="level3_limit"]').value = level3;
    row.querySelector('input[data-col="hysteresis"]').value = hyst;
  }
  // Hide modal
  document.getElementById('limitDefModal').style.display = 'none';

  // Clear current editing reference
  window.currentEditingItem = null;
}

document.getElementById('limitDefForm').addEventListener('submit', function(e) {
  e.preventDefault();

  const item = window.currentEditingItem;
  if (!item) return;

  // Update item with new values
  item.sm_name = document.getElementById('limitDefSmName').value;
  item.reg_type = document.getElementById('limitDefRegType').value;
  item.offset = document.getElementById('limitDefOffset').value;
  item.num = parseInt(document.getElementById('limitDefNum').value) || 1;

  // Close modal
  document.getElementById('limitDefModal').style.display = 'none';

  // Optional: Save to backend or mark dirty
});

document.querySelector('#limitDefModal .close').onclick = function() {
  document.getElementById('limitDefModal').style.display = 'none';
  console.log('Limit Definition modal closed');
};




function closeLimitsModal() {
  document.getElementById('limitsModal').style.display = 'none';
  document.getElementById('modalBackdrop').style.display = 'none';
  currentLimitsCell = null;
  currentLimitDefs = null;
}

function countLimitsDefUsers(defName) {
  console.log("table name :", defName);

  if (!defName) return 0;
  let count = 0;
  for (const alarm of alarmDefsData) {
    if ((alarm.limits_def_name || alarm.limit_def_name || alarm.limits_def || alarm.limit_defs_name) === defName) {
      // (adjust key name to whatever your alarm refers to the def by)
      count++;
    }
    // fallback: if alarms hold reference inside alarm.limit_defs.alarm_name etc:
    if (Array.isArray(alarm.limit_defs) && alarm.limit_defs.length) {
      // This is only if alarms embed the name inside; adjust as needed.
      if (alarm.limit_defs_name && alarm.limit_defs_name === defName) count++;
    }
  }
  return count;
}

function populateLimitsModalTable(limitsDef) {
  const modalContent = document.getElementById('limitsModalContent');
  modalContent.innerHTML = '';

  const table = document.createElement('table');
  table.classList.add('limits-table');
  table.id = 'limitsModalTable';

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  const columns = ['name', 'sm_name', 'reg_type', 'offset', 'num', 'write_data', 'read_data'];
  columns.forEach(col => {
    const th = document.createElement('th');
    th.textContent = col;
    headerRow.appendChild(th);
  });
  const selectTh = document.createElement('th');
  selectTh.textContent = 'Select';
  headerRow.appendChild(selectTh);

  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');

  limitsDef.forEach(item => {
    const row = document.createElement('tr');

    columns.forEach(col => {
      const td = document.createElement('td');
      let cellValue = item[col];
      if ((col === 'write_data' || col === 'read_data') && typeof cellValue !== 'string') {
        try { cellValue = JSON.stringify(cellValue || [], null, 2); } catch { cellValue = ''; }
      } else if (cellValue == null) {
        cellValue = '';
      }
      td.textContent = cellValue;
      td.setAttribute('data-col', col);
      td.setAttribute('contenteditable', 'true');
      row.appendChild(td);
    });

    const selTd = document.createElement('td');
    selTd.className = 'select-cell';
    selTd.textContent = 'â—¯';
    selTd.style.cursor = 'pointer';
    selTd.onclick = () => toggleRowSelect(row);
    row.appendChild(selTd);

    tbody.appendChild(row);
  });

  table.appendChild(tbody);
  modalContent.appendChild(table);

  selectedLimitRow = null;
}

function marshalLimitsTableToJsonString() {
  const table = document.getElementById('limitsModal');
  if (!table) {
    console.log("no table :");
    return '[]';
  }
  const rows = Array.from(table.querySelectorAll('tbody tr'));
  const columns = ['name', 'sm_name', 'reg_type', 'offset', 'num', 'write_data', 'read_data'];

  const arr = rows.map(row => {
    const obj = {};
    columns.forEach(col => {
      const td = row.querySelector(`td[data-col="${col}"]`);
      let val = td ? td.textContent.trim() : '';
      // try parse JSON for write_data/read_data
      if ((col === 'write_data' || col === 'read_data') && val) {
        try { obj[col] = JSON.parse(val); }
        catch { obj[col] = val; } // leave as string if invalid JSON
      } else if (col === 'num') {
        // coerce number fields
        const n = parseInt(val, 10);
        obj[col] = Number.isNaN(n) ? val : n;
      } else {
        obj[col] = val;
      }
    });
    return obj;
  });

  return JSON.stringify(arr);
}

function areLimitDefsEqual(defA, defB) {
  if (!Array.isArray(defA) || !Array.isArray(defB)) return false;
  if (defA.length !== defB.length) return false;

  for (let i = 0; i < defA.length; i++) {
    const a = defA[i];
    const b = defB[i];

    for (const key in a) {
      let valA = a[key];
      let valB = b[key];

      // Normalize arrays/objects to JSON strings for comparison
      if (typeof valA !== 'string' && (Array.isArray(valA) || typeof valA === 'object')) {
        try { valA = JSON.stringify(valA); } catch {}
      }
      if (typeof valB !== 'string' && (Array.isArray(valB) || typeof valB === 'object')) {
        try { valB = JSON.stringify(valB); } catch {}
      }

      // Normalize strings (trim, remove extra spaces)
      if (typeof valA === 'string') valA = valA.replace(/\s+/g, '');
      if (typeof valB === 'string') valB = valB.replace(/\s+/g, '');

      if (valA !== valB) {
        console.log(`Mismatch in key "${key}":`, valA, 'vs', valB);
        return false;
      }
    }
  }

  return true;
}
function xxareLimitDefsEqual(defA, defB) {
    console.log("def A:  ", defA);
    console.log("def B:  ", defB);

    if (!Array.isArray(defA)) 
    {
      console.log("def A is not an array ", defA);
      return false;
    }
    if (!Array.isArray(defB)) 
    {
      console.log("def B is not an array ", defB);
      return false;
    }
    if (defA.length !== defB.length) {
      console.log("defs have different lengths");
      return false;
    }
    for (let i = 0; i < defA.length; i++) {
      const a = defA[i];
     const b = defB[i];
    // Compare all keys (assuming same keys)
    for (const key in a) {
      if (JSON.stringify(a[key]) !== JSON.stringify(b[key])) {
        console.log("def KEY DIFF", key);
        console.log("def A string", JSON.stringify(a[key]));
        console.log("def B string", JSON.stringify(b[key]));
        return false;
      }
    }
  }
  return true;
}


/**
 * Finds a nested definition using "table.item" notation.
 * @param {Array} data - The nested limitsDefsMap array.
 * @param {string} path - The string path (e.g., "target_vars.online").
 * @returns {Object|null} - The found item object or null.
 use: 
    const existingDef = findLimitByPath(limitsDefsMap, "target_vars.online");

    if (existingDef) {
        console.log("Found definition:", existingDef);
    } else {
        console.log("Definition not found.");
    }
 */

function findLimitByPathName(data, tableName, itemName) {

    // If you're using the nested structure:
    return limitsDefsMap.get(`${tableName}:${itemName}`);
    
}


function findLimitByPath(data, path) {
    if (!path || !path.includes('.')) return null;

    const [tableName, itemName] = path.split('.');

    return findLimitByPathName(data, tableName, itemName);
}


/**
 * Adds a new definition to a specific table in the nested limitsDefsMap.
 * If the table doesn't exist, it creates it.
 * 
 * @param {Array} data - The nested limitsDefsMap array.
 * @param {string} tableName - The table to add to (e.g., "target_vars").
 * @param {string} itemName - The name of the new definition.
 * @param {Object} itemContent - The modal/limit data to store.
 * 
 * // Example: newLimitsName is "target_vars.online"
        if (!existingDef) {
            const [tableName, itemName] = newLimitsName.includes('.') 
                ? newLimitsName.split('.') 
                : ["default_table", newLimitsName];

            const success = addNewLimitDefinition(
                limitsDefsData, 
                tableName, 
                itemName, 
                modalData
            );

            if (success) {
                alert(`Created new limits definition "${itemName}" in table "${tableName}".`);
            }
        }

 */
function addNewLimitDefinition(data, tableName, itemName, itemContent) {
    // 1. Find or create the table
    let tableObj = data.find(t => t.table === tableName);

    if (!tableObj) {
        tableObj = {
            table: tableName,
            items: []
        };
        data.push(tableObj);
    }

    // 2. Double-check for duplicates within this specific table
    const exists = tableObj.items.some(i => i.name === itemName);
    if (exists) {
        console.warn(`Definition "${itemName}" already exists in "${tableName}".`);
        return false;
    }

    // 3. Create and push the new item
    const newItem = {
        name: itemName,
        limit_defs: itemContent
    };

    tableObj.items.push(newItem);
    return true;
}

document.getElementById('updateLimitsBtn').addEventListener('click', () => {
  if (!currentLimitsCell) {
    alert('No alarm selected.');
    return;
  }

  const tr = currentLimitsCell.parentElement;
  const alarmNum = tr.querySelector('td[data-col="alarm_num"]').textContent.trim();

  const alarm = alarmDefsData.find(a => String(a.alarm_num) === alarmNum);
  if (!alarm) {
    alert('Alarm not found.');
    return;
  }

  const modalTable = document.querySelector('#limitsModalContent table');
  if (!modalTable) {
    alert('No limits table found.');
    return;
  }

  const firstRow = modalTable.querySelector('tbody tr');
  if (!firstRow) {
    alert('No data in limits table.');
    return;
  }

  const nameCell = firstRow.querySelector('td[data-col="name"]');
  if (!nameCell) {
    alert('Limits def name cell not found.');
    return;
  }

  const newLimitsName = nameCell.textContent.trim();
  if (!newLimitsName) {
    alert('Limits def name is empty.');
    return;
  }
  console.log("newLimitsName :", newLimitsName);

  // Marshal modal table data to array
  const modalData = JSON.parse(marshalLimitsTableToJsonString());

  // Use limitsDefsMap keyed by "alarm_limits:<name>"
  const key = `alarm_limits:${newLimitsName}`;
  let existingDef = limitsDefsMap.get(key);
  console.log("existingDef :", existingDef);

  if (!existingDef) {
    // New def: add to map
    modalData.forEach(item => {
      limitsDefsMap.set(`alarm_limits:${item.name}`, item);
    });
    alert(`Created new limits definition "${newLimitsName}".`);
  } else {
    // Existing def: compare modal data with saved def
    if (!areLimitDefsEqual([existingDef], modalData)) {
      console.log("existing limits_defs:", existingDef);
      console.log("modalData :", modalData);

      const ok = confirm(`Limits definition "${newLimitsName}" has changes. Update the saved definition?`);
      if (!ok) {
        alert('Update cancelled.');
        return;
      }
      // Update all items in map for this limits def
      modalData.forEach(item => {
        limitsDefsMap.set(`alarm_limits:${item.name}`, item);
      });
      alert(`Limits definition "${newLimitsName}" updated.`);
    } else {
      alert(`No changes detected in limits definition "${newLimitsName}".`);
    }
  }

  // Update alarm's limits_def name and embedded defs
  alarm.limits_def = newLimitsName;
  alarm.limit_defs = modalData;

  // Update limits_def cell in alarm table
  const limitsDefCell = tr.querySelector('td[data-col="limits_def"]');
  if (limitsDefCell) {
    limitsDefCell.textContent = newLimitsName;
  }

  // Optionally close modal or keep open
});


document.getElementById('getLimitsBtn').addEventListener('click', () => {
  const jstring = marshalLimitsTableToJsonString();

  let tableName = '';
  try {
    const arr = JSON.parse(jstring);
    if (Array.isArray(arr) && arr.length > 0) {
      tableName = arr[0].name;
      console.log('Table name:', tableName);
    } else {
      alert('No limits data found in the table.');
      return;
    }
  } catch (e) {
    alert('Failed to parse limits data.');
    return;
  }

  console.log('Looking for limits def:', tableName);
//      const existingDef = findLimitByPath(limitsDefsData, "target_vars.online");

  let limitsDef = findLimitByPathName(limitsDefsMap, "alarm_limits", tableName);
  //let limitsDef = limitsDefsData.find(ld => ld.name === tableName);

  if (!limitsDef) {
    alert(`Limits definition named "${tableName}" not found.`);
    return;
  }

  if (!Array.isArray(limitsDef)) {
    limitsDef = [limitsDef];
  }

  console.log('LimitsDef data:', limitsDef);

  populateLimitsModalTable(limitsDef);
});

// --- Get Limit from Target ---
async function getLimit(index) {
    const items = Array.from(limitsDefsMap.values());
    const item = items[index];
    if (!item) return;

    const ip = document.getElementById('limitsTargetIp').value;
    const port = document.getElementById('limitsTargetPort').value;
    const secure = document.getElementById('limitsTargetSecure').checked;

    const url = `${secure ? 'https' : 'http'}://${ip}:${port}/get_limit?name=${encodeURIComponent(item.name)}`;

    try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();

        // Update target fields in UI
        const tr = document.querySelector(`#limitsTable tbody tr[data-index="${index}"]`);
        if (tr) {
            tr.querySelector('span[data-col="target_level1"]').textContent = data.level1 ?? '';
            tr.querySelector('span[data-col="target_level2"]').textContent = data.level2 ?? '';
            tr.querySelector('span[data-col="target_level3"]').textContent = data.level3 ?? '';
            tr.querySelector('span[data-col="target_hysteresis"]').textContent = data.hysteresis ?? '';
        }

        console.log('Got limit data:', data);
    } catch (err) {
        alert('Get error: ' + err.message);
    }
}

// --- Set Limit to Target ---
async function setLimit(index) {
    const items = Array.from(limitsDefsMap.values());
    const item = items[index];
    if (!item) return;

    const tr = document.querySelector(`#limitsTable tbody tr[data-index="${index}"]`);
    if (!tr) return;

    const level1 = Number(tr.querySelector('input[data-col="level1_limit"]').value);
    const level2 = Number(tr.querySelector('input[data-col="level2_limit"]').value);
    const level3 = Number(tr.querySelector('input[data-col="level3_limit"]').value);
    const hysteresis = Number(tr.querySelector('input[data-col="hysteresis"]').value);

    const ip = document.getElementById('limitsTargetIp').value;
    const port = document.getElementById('limitsTargetPort').value;
    const secure = document.getElementById('limitsTargetSecure').checked;

    const url = `${secure ? 'https' : 'http'}://${ip}:${port}/set_limit`;

    const payload = {
        name: item.name,
        level1: level1,
        level2: level2,
        level3: level3,
        hysteresis: hysteresis
    };

    try {
        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        alert('Set limit success: ' + JSON.stringify(data));
    } catch (err) {
        alert('Set error: ' + err.message);
    }
}

document.getElementById('saveLimitsBtn').addEventListener('click', () => {
  try {
    let tableName = '';
    const jstring = marshalLimitsTableToJsonString();

    try {
        const arr = JSON.parse(jstring);
        if (Array.isArray(arr) && arr.length > 0) {
            tableName = arr[0].name;  // "Terminal Over Voltage"
            console.log('Table name:', tableName);
        } else {
            console.log('JSON array is empty or invalid');
        }
    } catch (e) {
        console.error('Invalid JSON string', e);
    }

    
    console.log("jstring :",jstring);
    const users = countLimitsDefUsers(tableName);
    console.log(" users :",users);

    return;

    const editedText = document.getElementById('limitsModalContent').textContent;
    const parsed = JSON.parse(editedText);
    // Update currentLimitDefs and cell display
    currentLimitDefs = parsed;

    // Update the alarmDefsData model
    for (const alarm of alarmDefsData) {
      if (String(alarm.alarm_num) === currentLimitsCell.parentElement.querySelector('td[data-col="alarm_num"]').textContent.trim()) {
        alarm.limit_defs = currentLimitDefs;
        // Update limits_structure cell text to new name if changed
        const limitsCell = currentLimitsCell;
        limitsCell.textContent = currentLimitDefs.name || limitsCell.textContent;
        break;
      }
    }

    closeLimitsModal();
  } catch (e) {
    alert('Invalid JSON: ' + e.message);
  }
});

// document.getElementById('cancelLimitsBtn').addEventListener('click', () => {
//   closeLimitsModal();
// });

// Dummy get/set target buttons
document.getElementById('getTargetBtn').addEventListener('click', () => {
  alert('Dummy Get Target operation - implement your logic here');
});

document.getElementById('setTargetBtn').addEventListener('click', () => {
  alert('Dummy Set Target operation - implement your logic here');
});
// let currentLimitsCell = null;


function closeLimitsModal() {
  document.getElementById('limitsModal').style.display = 'none';
  document.getElementById('modalBackdrop').style.display = 'none';
  currentLimitsCell = null;
  currentLimitDefs = null;
}

function closeJsonModal() {
  document.getElementById('jsonModal').style.display = 'none';
  document.getElementById('modalBackdrop').style.display = 'none';
  currentCell = null;
}


// actions modal
let currentCell = null;

function openJsonModal(cell) {
  currentCell = cell;
  const jsonText = cell.textContent.trim();
  try {
    const parsed = JSON.parse(jsonText);
    document.getElementById('jsonEditor').value = JSON.stringify(parsed, null, 2);
  } catch (e) {
    // If invalid JSON, just show raw text
    document.getElementById('jsonEditor').value = jsonText;
  }
  document.getElementById('jsonModal').style.display = 'block';
  document.getElementById('modalBackdrop').style.display = 'block';
}

function closeJsonModal() {
  document.getElementById('jsonModal').style.display = 'none';
  document.getElementById('modalBackdrop').style.display = 'none';
  currentCell = null;
}

document.getElementById('saveJsonBtn').addEventListener('click', () => {
  const editedText = document.getElementById('jsonEditor').value;
  try {
    JSON.parse(editedText); // Validate JSON
    if (currentCell) {
      currentCell.textContent = editedText;
    }
    closeJsonModal();
  } catch (e) {
    alert('Invalid JSON: ' + e.message);
  }
});

// document.getElementById('cancelJsonBtn').addEventListener('click', () => {
//   closeJsonModal();
// });

// --- Target tab functions ---

async function loadLimitsTargetConfig() {
    setStatus('Loading limits  target config...');
    try {
        const res = await fetch(apiBase + '/target/config');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const config = await res.json();
        document.getElementById('limitsTargetIp').value = config.ip;
        document.getElementById('limitsTargetPort').value = config.port;
        document.getElementById('limitsTargetSecure').checked = config.secure;
        setStatus('Limits Target config loaded.', false);
    } catch (err) {
        console.error(err);
        setStatus('Error loading target config: ' + err.message, true);
    }
}

async function saveLimitsTargetConfig() {
    const config = {
        ip: document.getElementById('limitsTargetIp').value,
        port: parseInt(document.getElementById('targetPort').value),
        secure: document.getElementById('targetSecure').checked
    };
    setStatus('Saving Limits target config...');
    try {
        const res = await fetch(apiBase + '/target/config', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(config)
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || ('HTTP ' + res.status));
        setStatus('Target config saved.', false);
    } catch (err) {
        console.error(err);
        setStatus('Error saving target config: ' + err.message, true);
    }
}

// --- Target tab functions ---

async function loadTargetConfig() {
    setStatus('Loading target config...');
    try {
        const res = await fetch(apiBase + '/target/config');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const config = await res.json();
        document.getElementById('targetIp').value = config.ip;
        document.getElementById('targetPort').value = config.port;
        document.getElementById('targetSecure').checked = config.secure;
        setStatus('Target config loaded.', false);
    } catch (err) {
        console.error(err);
        setStatus('Error loading target config: ' + err.message, true);
    }
}

async function saveTargetConfig() {
    const config = {
        ip: document.getElementById('targetIp').value,
        port: parseInt(document.getElementById('targetPort').value),
        secure: document.getElementById('targetSecure').checked
    };
    setStatus('Saving target config...');
    try {
        const res = await fetch(apiBase + '/target/config', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(config)
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || ('HTTP ' + res.status));
        setStatus('Target config saved.', false);
    } catch (err) {
        console.error(err);
        setStatus('Error saving target config: ' + err.message, true);
    }
}

function addTargetVar() {
    const tbody = document.querySelector('#targetVarsTable tbody');
    const tr = document.createElement('tr');
    
    const cols = ['var_name', 'sm_name', 'reg_type', 'offset', 'num', 'write data', 'read data'];
    const defaults = {
        var_name: 'rtos:hold:alarm_limits',
        sm_name: 'rtos',
        reg_type: 'mb_hold',
        offset: '9',
        num: '4',
        data: '[]'
    };
    
    cols.forEach(col => {
        const td = document.createElement('td');
        td.textContent = defaults[col];
        td.setAttribute('data-col', col);
        td.setAttribute('contenteditable', 'true');
        tr.appendChild(td);
    });
    
    const actionTd = document.createElement('td');
    actionTd.className = 'action-cell';
    
    const getBtn = document.createElement('button');
    getBtn.textContent = 'ðŸ“¥ Get';
    getBtn.onclick = () => getTargetData(tr);
    actionTd.appendChild(getBtn);
    
    const setBtn = document.createElement('button');
    setBtn.textContent = 'ðŸ“¤ Set';
    setBtn.onclick = () => setTargetData(tr);
    actionTd.appendChild(setBtn);
    
    const delBtn = document.createElement('button');
    delBtn.textContent = 'ðŸ—‘ï¸';
    delBtn.onclick = () => tr.remove();
    actionTd.appendChild(delBtn);
    
    tr.appendChild(actionTd);
    tbody.appendChild(tr);
}

async function getTargetData(tr) {
    const cells = tr.querySelectorAll('td[data-col]');
    const payload = {
        sm_name: cells[1].textContent.trim(),
        reg_type: cells[2].textContent.trim(),
        offset: cells[3].textContent.trim(),
        num: parseInt(cells[4].textContent.trim())
    };
    
    setStatus('Getting data from target...');
    try {
        const res = await fetch(apiBase + '/target/get', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || ('HTTP ' + res.status));
        
        // Update data column
        cells[6].textContent = JSON.stringify(data.read_data || []);
        setStatus('Got data: ' + JSON.stringify(data), false);
    } catch (err) {
        console.error(err);
        setStatus('Error getting data: ' + err.message, true);
    }
}

async function setTargetData(tr) {
    const cells = tr.querySelectorAll('td[data-col]');
    const dataStr = cells[5].textContent.trim();
    let dataArray;
    try {
        dataArray = JSON.parse(dataStr);
    } catch (e) {
        setStatus('Invalid JSON in data field', true);
        return;
    }
    
    const payload = {
        sm_name: cells[1].textContent.trim(),
        reg_type: cells[2].textContent.trim(),
        offset: cells[3].textContent.trim(),
        write_data: dataArray
    };
    
    setStatus('Setting data on target...');
    try {
        const res = await fetch(apiBase + '/target/set', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || ('HTTP ' + res.status));
        
        setStatus('Set data: ' + JSON.stringify(data), false);
    } catch (err) {
        console.error(err);
        setStatus('Error setting data: ' + err.message, true);
    }
}

// --- Var-list integration ---
async function reloadListOptions() {
    populateJsonDefSelect();
    reloadVarListOptions();

}

async function reloadVarListOptions() {
    setStatus('Loading variable lists...');
    const select = document.getElementById('varListSelect');
    if (!select) return;

    try {
        const res = await fetch(pubApiBase + '/list');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        const files = data.files || [];

        select.innerHTML = '<option value="">(select a file)</option>';
        
        if (files.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = '(no var_lists/*.json found)';
            select.appendChild(opt);
            setStatus('No var list files found in var_lists.', true);
            return;
        }

        files.forEach(f => {
            const opt = document.createElement('option');
            opt.value = f;
            opt.textContent = f;
            select.appendChild(opt);
        });

        setStatus('Variable lists loaded from ' + (data.directory || 'var_lists') + '.', false);
    } catch (err) {
        console.error(err);
        setStatus('Error loading var list files: ' + err.message, true);
    }
}

function populateTargetVarsFromVarList(varListJson) {
    console.log(" running pop function\n");
    const tbody = document.querySelector('#targetVarsTable tbody');
    if (!tbody) return;
    tbody.innerHTML = '';

    if (!Array.isArray(varListJson)) {
        console.warn('Var list JSON is not an array:', varListJson);
        setStatus('Var list format error: expected array of tables.', true);
        return;
    }

    let totalVars = 0;

    varListJson.forEach(tableObj => {
        if (!tableObj.items || !Array.isArray(tableObj.items)) {
            console.warn('Table object missing items[]:', tableObj);
            return;
        }

        tableObj.items.forEach(item => {
            const varName = item.name || '';
            const smName = item.sm_name || 'rtos';
            const regType = item.reg_type || 'mb_hold';
            const offset = item.offset != null ? String(item.offset) : '0';
            const num = item.num != null ? String(item.num) : '1';

            let dataArray = [];
            let writeDataArray = [];
            if (Array.isArray(item.write_data)) {
                writeDataArray = item.write_data;
            } else if (Array.isArray(item.read_data)) {
                writeDataArray = item.read_data;
            }

            const tr = document.createElement('tr');
            // IMPORTANT: Must match the exact column structure of addTargetVar()
            const cols = ['var_name', 'sm_name', 'reg_type', 'offset', 'num', 'write_data', 'read_data'];
            const defaults = {
                var_name: varName,
                sm_name: smName,
                reg_type: regType,
                offset: offset,
                num: num,
                write_data: JSON.stringify(writeDataArray),
                read_data: '[]' // JSON.stringify(writeDataArray)
            };
 
            cols.forEach(col => {
                const td = document.createElement('td');
                td.textContent = defaults[col] ?? '';
                td.setAttribute('data-col', col);
                td.setAttribute('contenteditable', 'true');
                tr.appendChild(td);
            });

            const actionTd = document.createElement('td');
            actionTd.className = 'action-cell';

            const getBtn = document.createElement('button');
            getBtn.textContent = 'ðŸ“¥ Get';  // this one is from the target tab
            getBtn.onclick = () => getTargetData(tr);
            actionTd.appendChild(getBtn);

            const setBtn = document.createElement('button');
            setBtn.textContent = 'ðŸ“¤ Set';
            setBtn.onclick = () => setTargetData(tr);
            actionTd.appendChild(setBtn);

            const delBtn = document.createElement('button');
            delBtn.textContent = 'ðŸ—‘ï¸';
            delBtn.onclick = () => tr.remove();
            actionTd.appendChild(delBtn);

            tr.appendChild(actionTd);
            tbody.appendChild(tr);
            totalVars++;
        });
    });

    setStatus('Loaded ' + totalVars + ' variable(s) from list.', false);
}

async function loadSelectedVarList() {
  const loadListBtn = document.getElementById('loadListBtn');
  const jsonSelect = document.getElementById('jsonDefSelect');
  const fileInput = document.getElementById('varListSelect');

  try {
    let data = null;

    if (loadListBtn.textContent.includes('File')) {
      // Load from file
      //const file = fileInput.files[0];
      const file = fileInput.value;
      if (!file) throw new Error('No file selected.');

      const formData = new FormData();
      formData.append('file', file);

      setStatus('Loading var list from file: ' + file.name + ' ...');

      const res = await fetch(pubApiBase + '/load_var_list', {
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ file_name: file }),
        method: 'POST',
      });

      data = await res.json();
      if (!res.ok) throw new Error(data.message || ('HTTP ' + res.status));

    } else if (loadListBtn.textContent.includes('JSON')) {
      // Load from JSON map prefix
      const selectedPrefix = jsonSelect.value;
      if (!selectedPrefix) throw new Error('No JSON group selected.');

      setStatus('Loading var list from JSON group: ' + selectedPrefix + ' ...');

      // Filter limitsDefsMap entries by prefix
      const items = [];
      for (const [key, value] of limitsDefsMap.entries()) {
        if (key.startsWith(selectedPrefix + ':')) {
          items.push(value);
        }
      }

      //data = { items }; // Wrap in items array as expected
      data = [{"table": "target_vars","items":items}]; // Wrap in items array as expected

    } else {
      throw new Error('Please select a file or JSON to load.');
    }

    console.log('Loaded data:', data);
    populateTargetVarsFromVarList(data);

  } catch (err) {
    console.error(err);
    setStatus('Error loading var list: ' + err.message, true);
  }
}

// --- Save List / Get All / Save All ---

function collectVarRows() {
    const rows = [];
    document.querySelectorAll('#targetVarsTable tbody tr').forEach(tr => {
        const obj = {};
        tr.querySelectorAll('td[data-col]').forEach(td => {
            const col = td.getAttribute('data-col');
            let val = td.textContent.trim();
            // if (col === 'offset' || col === 'num') {
            //     val = val === '' ? null : Number(val);
            // }
            obj[col] = val;
        });
        rows.push(obj);
    });
    return rows;
}

async function saveVarList() {
  const jsonSelect = document.getElementById('jsonDefSelect');
  const fileSelect = document.getElementById('varListSelect');
  const loadListBtn = document.getElementById('loadListBtn');

  // Prompt user for filename (for file save) or just confirm for JSON save
  let fileName = '';
  if (loadListBtn.textContent.includes('File')) {
    fileName = prompt('Enter filename to save (e.g., my_vars.json):', fileSelect.value || '');
    if (!fileName || fileName.trim() === '') {
      setStatus('Save cancelled - no filename provided.', true);
      return;
    }
    fileName = fileName.trim().endsWith('.json') ? fileName.trim() : fileName.trim() + '.json';
  }

  const items = collectVarRows().map(r => {
    const offsetText = (r.offset ?? '').toString().trim();
    const numText = (r.num ?? '').toString().trim();
    const numVal = numText === '' ? 1 : Number(numText);

    let writeData = [];
    try {
      writeData = r.write_data ? JSON.parse(r.write_data) : [];
    } catch (e) {
      writeData = [];
    }

    return {
      name: r.var_name,
      sm_name: r.sm_name || 'rtos',
      reg_type: r.reg_type || 'mb_hold',
      offset: offsetText,
      num: isNaN(numVal) ? 1 : numVal,
      write_data: writeData
    };
  });

  if (loadListBtn.textContent.includes('File')) {
    // Save to file via backend
    const payload = [
      {
        table: 'vars',
        items: items
      }
    ];

    setStatus('Saving variable list to ' + fileName + ' ...');

    try {
      const res = await fetch(pubApiBase + '/save_var_list', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ file_name: fileName, data: payload })
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.message || ('HTTP ' + res.status));
      setStatus('Saved var list to ' + fileName + '.', false);

      await reloadVarListOptions();
      if (fileSelect) fileSelect.value = fileName;
    } catch (err) {
      console.error(err);
      setStatus('Error saving var list: ' + err.message, true);
    }
  } else if (loadListBtn.textContent.includes('JSON')) {
    // Save directly into limitsDefsMap in memory
    const selectedGroup = jsonSelect.value;
    if (!selectedGroup) {
      setStatus('No JSON group selected for saving.', true);
      return;
    }

    setStatus('Saving variable list to JSON group: ' + selectedGroup + ' ...');

    // Remove existing entries with this prefix
    for (const key of Array.from(limitsDefsMap.keys())) {
      if (key.startsWith(selectedGroup + ':')) {
        limitsDefsMap.delete(key);
      }
    }

    // Add new entries with keys prefixed by selectedGroup
    items.forEach(item => {
      const key = `${selectedGroup}:${item.name}`;
      limitsDefsMap.set(key, item);
    });

    setStatus('Saved variable list to JSON group: ' + selectedGroup + '.', false);

    // Optionally refresh UI or save memory to persistent storage here
  } else {
    setStatus('Please select a file or JSON group to save.', true);
  }
}


async function getAllTarget() {
    const rows = Array.from(document.querySelectorAll('#targetVarsTable tbody tr'));
    if (!rows.length) {
        setStatus('No rows to Get.', true);
        return;
    }

    setStatus('Getting data for all rows...');
    for (const tr of rows) {
        await getTargetData(tr);
    }
    setStatus('Completed Get All.', false);
}

async function setAllTarget() {
    const rows = Array.from(document.querySelectorAll('#targetVarsTable tbody tr'));
    if (!rows.length) {
        setStatus('No rows to Save.', true);
        return;
    }

    setStatus('Saving data for all rows...');
    for (const tr of rows) {
        await setTargetData(tr);
    }
    setStatus('Completed Save All.', false);
}

// Wire buttons
document.getElementById('loadBtn').addEventListener('click', loadFromConfig);
document.getElementById('saveBtn').addEventListener('click', savetoConfig);
document.getElementById('exportBtn').addEventListener('click', exportJSON);
document.getElementById('importBtn').addEventListener('click', importJSON);
document.getElementById('addAlarmBtn').addEventListener('click', addNewAlarm);

// Initial load
loadFromConfig();
loadTargetConfig();
populateJsonDefSelect();
reloadVarListOptions();

// // Render limits values table on load
// window.addEventListener('load', () => {
//     getAllLimitValues();
// });
</script>
</body>
</html>