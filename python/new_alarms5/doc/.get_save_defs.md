Thanks for sharing your full `index.html`. To help you integrate the "Get Limits" button logic and modal population cleanly, I’ll outline the key steps and provide the code snippets you can add or modify in your existing file.

---

### 1. Consolidate your "Get Limits" button handler
done 
Add this script block or integrate into your existing JS:

```js
document.getElementById('getLimitsBtn').addEventListener('click', () => {
  const jstring = marshalLimitsTableToJsonString();

  let tableName = '';
  try {
    const arr = JSON.parse(jstring);
    if (Array.isArray(arr) && arr.length > 0) {
      tableName = arr[0].name;
      console.log('Table name:', tableName);
    } else {
      alert('No limits data found in the table.');
      return;
    }
  } catch (e) {
    alert('Failed to parse limits data.');
    return;
  }

  console.log('Looking for limits def:', tableName);

  let limitsDef = limitsDefsData.find(ld => ld.name === tableName);

  if (!limitsDef) {
    alert(`Limits definition named "${tableName}" not found.`);
    return;
  }

  if (!Array.isArray(limitsDef)) {
    limitsDef = [limitsDef];
  }

  console.log('LimitsDef data:', limitsDef);

  populateLimitsModalTable(limitsDef);
});
```

---

### 2. Implement `populateLimitsModalTable(limitsDef)`
done
This function clears the modal table and fills it with the new limitsDef data:

```js
function populateLimitsModalTable(limitsDef) {
  const modalContent = document.getElementById('limitsModalContent');
  modalContent.innerHTML = '';

  const table = document.createElement('table');
  table.classList.add('limits-table');
  table.id = 'limitsModalTable';

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  const columns = ['name', 'sm_name', 'reg_type', 'offset', 'num', 'write_data', 'read_data'];
  columns.forEach(col => {
    const th = document.createElement('th');
    th.textContent = col;
    headerRow.appendChild(th);
  });
  const selectTh = document.createElement('th');
  selectTh.textContent = 'Select';
  headerRow.appendChild(selectTh);

  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');

  limitsDef.forEach(item => {
    const row = document.createElement('tr');

    columns.forEach(col => {
      const td = document.createElement('td');
      let cellValue = item[col];
      if ((col === 'write_data' || col === 'read_data') && typeof cellValue !== 'string') {
        try { cellValue = JSON.stringify(cellValue || [], null, 2); } catch { cellValue = ''; }
      } else if (cellValue == null) {
        cellValue = '';
      }
      td.textContent = cellValue;
      td.setAttribute('data-col', col);
      td.setAttribute('contenteditable', 'true');
      row.appendChild(td);
    });

    const selTd = document.createElement('td');
    selTd.className = 'select-cell';
    selTd.textContent = '◯';
    selTd.style.cursor = 'pointer';
    selTd.onclick = () => toggleRowSelect(row);
    row.appendChild(selTd);

    tbody.appendChild(row);
  });

  table.appendChild(tbody);
  modalContent.appendChild(table);

  selectedLimitRow = null;
}
```

---

### 3. Add or confirm your row selection helpers

```js
let selectedLimitRow = null;

function toggleRowSelect(row) {
  if (selectedLimitRow === row) {
    deselectRow(row);
    selectedLimitRow = null;
    return;
  }
  if (selectedLimitRow) deselectRow(selectedLimitRow);
  selectedLimitRow = row;
  row.classList.add('selected-limit-row');
  const selCell = row.querySelector('.select-cell');
  if (selCell) selCell.textContent = '◉';
}

function deselectRow(row) {
  row.classList.remove('selected-limit-row');
  const selCell = row.querySelector('.select-cell');
  if (selCell) selCell.textContent = '◯';
}
```

Add CSS for `.selected-limit-row` to highlight the selected row:

```css
.selected-limit-row {
  background-color: #d0eaff;
}
```

---

### 4. Add a button to update the current alarm's limits_def field

Add a button in your modal controls, e.g.:

```html
<button id="updateAlarmLimitsBtn">Update Alarm Limits Def</button>
```

And wire it up:

```js
document.getElementById('updateAlarmLimitsBtn').addEventListener('click', () => {
  if (!selectedLimitRow) {
    alert('Please select a row to update the alarm limits definition.');
    return;
  }

  // Marshal the modal table to JSON string
  const jsonString = marshalLimitsTableToJsonString();

  // Get the limits def name from the first row's 'name' column
  const firstRow = document.querySelector('#limitsModalTable tbody tr');
  if (!firstRow) {
    alert('No data in limits table.');
    return;
  }
  const defName = firstRow.querySelector('td[data-col="name"]').textContent.trim();

  // Update the current alarm's limits_def field in your alarmDefsData
  const alarmRow = currentLimitsCell && currentLimitsCell.parentElement;
  if (!alarmRow) {
    alert('No alarm context found.');
    return;
  }
  const alarmNum = alarmRow.querySelector('td[data-col="alarm_num"]').textContent.trim();
  const alarm = alarmDefsData.find(a => String(a.alarm_num) === alarmNum);
  if (!alarm) {
    alert('Alarm not found.');
    return;
  }

  // Update alarm's limits_def name and embedded defs (adjust field names as needed)
  alarm.limits_def_name = defName;
  alarm.limit_defs = JSON.parse(jsonString);

  alert(`Alarm limits definition updated to "${defName}". Don't forget to save your changes.`);

  // Optionally close modal or keep open for further edits
});
```

---

### 5. Summary

- The **Get Limits** button loads a limits def by name and populates the modal table.
- The user can edit the modal table.
- The **Update Alarm Limits Def** button updates the current alarm's limits def reference and embedded defs.
- You still need to implement your save logic to persist changes to the backend.

---
to do make limit_defs like the vars files
we  "limits_def": [
        {
            "name": "Terminal Over Voltage",
            "sm_name": "rtos",
        }
]

have this

   {
    "limits_defs" : [
        "table": "target_vars",
        "items": [
            {
                "name": "online",
                "sm_name": "rtos",
                "reg_type": "mb_hold",
                "offset": "online",
                "num": 4,
                "write_data": [
                    2,
                    3,
                    4,
                    5
                ],
                "read_data": []
            }
        ]
    ]
   }




If you want, I can help you integrate this fully into your uploaded `index.html` or help with the save logic next. Just say the word!

CREATE TABLE stored_queries (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    query_text VARCHAR(255)
);
INSERT INTO stored_queries VALUES(1,'SELECT * FROM data_definitions');
INSERT INTO stored_queries VALUES(2,'SELECT * FROM stored_queries');


The issue is that although you update `limitsDefsData` in memory, the changes are not persisted back to your backend or saved in your main data source. So when you reload or reopen the modal, it fetches the original data again, losing your in-memory edits.

### How to fix this:

1. **Persist the updated `limitsDefsData` to your backend or main storage** after you update or create a new limits def.  
2. **Reload or refresh your local data (`limitsDefsData` and `alarmDefsData`) from the backend** after saving, so the modal opens with the latest data.

---

### Suggested approach:

#### A) Add a function to save your updated data to backend

Example (adjust endpoint and payload as per your backend API):

```js
async function saveLimitsDefsToBackend() {
  try {
    const payload = {
      alarm_definitions: alarmDefsData,
      limits_definitions: limitsDefsData,
      // add other data if needed
    };

    const res = await fetch(apiBase + '/config', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Save failed: ${res.status} ${text}`);
    }

    console.log('Limits definitions saved successfully.');
  } catch (err) {
    console.error('Error saving limits definitions:', err);
    alert('Failed to save limits definitions: ' + err.message);
  }
}
```

#### B) Call this function after updating or creating a limits def

Modify your update handler to:

```js
// After updating limitsDefsData and alarmDefsData in memory
await saveLimitsDefsToBackend();

// Optionally reload data from backend to refresh local state
await loadFromDB();
```

---

### Why this matters

- Your frontend edits are only in memory until saved.
- Reloading modal or page fetches fresh data from backend.
- Without saving, changes are lost on reload.

---

### Summary

- Update your backend with the new/updated limits defs.
- Reload your frontend data after save.
- Then reopening the modal will show the updated data.

---

If you want, I can help you integrate this save flow into your existing code!